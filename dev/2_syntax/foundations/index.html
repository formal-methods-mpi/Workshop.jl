<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Foundations · A fresh approach to scientific computing</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://formal-methods-mpi.github.io/Workshop.jl/2_syntax/foundations/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="A fresh approach to scientific computing logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="A fresh approach to scientific computing logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">A fresh approach to scientific computing</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Chapter 0: Preparation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../0_preparation/introduction/">Introduction</a></li><li><a class="tocitem" href="../../0_preparation/preparation/">Setup</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Chapter 1: Workflow</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../1_workflow/usage/">Working with Julia in VSCode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Chapter 2: Syntax</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../syntax/">Theory</a></li><li><a class="tocitem" href="../exercise/">Exercise</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Chapter 3: Types</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../3_types/types/">Theory</a></li><li><a class="tocitem" href="../../3_types/exercise/">Exercise</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Chapter 4: Multiple Dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../4_dispatch/dispatch/">Theory</a></li><li><a class="tocitem" href="../../4_dispatch/exercise/">Exercise</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Advanced Materials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../5_advanced/intro/">Introduction</a></li><li><a class="tocitem" href="../../5_advanced/dual/">Automatic Differentiation</a></li><li><a class="tocitem" href="../../5_advanced/workflow/">Workflow</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Foundations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Foundations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/formal-methods-mpi/Workshop.jl/blob/main/docs/src/2_syntax/foundations.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Foundations"><a class="docs-heading-anchor" href="#Foundations">Foundations</a><a id="Foundations-1"></a><a class="docs-heading-anchor-permalink" href="#Foundations" title="Permalink"></a></h1><p>Welcome back to the workshop! We hope that you had fun following along and that we sparked your interest for this fascinating programming language. Please don&#39;t hesitate to ask us any questions or provide feedback on what you liked and didn&#39;t like or thought was too easy or too hard. Your input is always welcome and appreciated!</p><p>Next, we will dive into the necessary foundations of the language.</p><h2 id="Variable-assignment"><a class="docs-heading-anchor" href="#Variable-assignment">Variable assignment</a><a id="Variable-assignment-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-assignment" title="Permalink"></a></h2><p>In Julia, variables are used to store data and represent values in your program. Variables have a name and are assigned a value using the assignment operator =. Julia supports both regular (ASCII) variable names and Unicode variable names.</p><p>Regular variables are named using alphanumeric characters and underscores, starting with a letter or underscore.</p><pre><code class="language-julia hljs">x = 1
my_variable = &quot;awesome&quot;
φ = 1.618</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.618</code></pre><p>Unicode variables allow you to use a wider range of characters, including mathematical symbols, Greek letters, and other special characters. To create a Unicode variable, type a backslash followed by the Unicode character name, and then press the Tab key to convert it into the corresponding Unicode symbol. For example, type \alpha and then press Tab to create the α variable.</p><pre><code class="language-julia hljs">α = 0.05
β₁ = 1.2
Δt = 0.01</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.01</code></pre><h3 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h3><ol><li>Assign the integer value 42 to a variable named the<em>answer</em>to_life.</li><li>Assign the string &quot;Julia is fun!&quot; to a variable named yay.</li><li>Assign the value of 1 + √2 divided by 2 to the variable φ (phi). Remember to use the Unicode character: type \phi or \sqrt and press Tab to convert it.</li></ol><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><p>Excellent! Now that you have a good understanding of variables and the expressive nature of Julia, let&#39;s dive into the topic of functions.</p><p>In programming, functions are reusable blocks of code that serve a specific purpose. They play a crucial role in organizing and modularizing code, which in turn enhances its readability and maintainability. For instance, if you&#39;ve written a chunk of code that performs a specific task or multiple tasks, it would be beneficial to break down the code into individual functions and give each a descriptive name. This approach makes your code more comprehensible and easier to work with. Functions also enable code reuse, minimizing redundancy and simplifying updates, which can save time and effort in the long run.</p><p>The basic syntax for defining a function in Julia is as follows:</p><pre><code class="language-julia hljs">function function_name(arguments)
    # function body
    return output
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">function_name (generic function with 1 method)</code></pre><p>The <code>return</code> keyword plays a vital role in specifying the value that a <code>function</code> should output. When no return statement is explicitly provided, the function will return the value of the last expression evaluated in the function body.</p><p>However, it is generally good practice to include a <code>return</code> statement when defining functions using the <code>function</code> keyword, even if the function returns <code>nothing</code>. This approach helps to eliminate ambiguity and ensures that the function&#39;s expected output is clear to anyone who reads it.</p><p>For example:</p><pre><code class="language-julia hljs">function add(x, y)
    return x + y
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">add (generic function with 1 method)</code></pre><p>You can also write:</p><pre><code class="language-julia hljs">my_function(arguments) = &quot;function body&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_function (generic function with 1 method)</code></pre><p>For example:</p><pre><code class="language-julia hljs">square(x) = x * x</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">square (generic function with 1 method)</code></pre><h3 id="Exercises-2"><a class="docs-heading-anchor" href="#Exercises-2">Exercises</a><a class="docs-heading-anchor-permalink" href="#Exercises-2" title="Permalink"></a></h3><ol><li>Write a function called divide that takes two arguments and returns the result of dividing the first argument by the second.</li><li>Write a function called cube that takes one argument and returns the cube of the input number.</li><li>Write a function that checks if a number is even. The function should take one argument and return a <code>Bool</code>.</li></ol><p>TODO: Solutions.</p><details>
<summary>Show solution</summary>
<br><div class="admonition is-success"><header class="admonition-header">Solution</header><div class="admonition-body"><pre><code class="language-julia hljs">x = 123
y = &quot;another solutions I have to do&quot;</code></pre></div></div></details><h2 id="Vectors"><a class="docs-heading-anchor" href="#Vectors">Vectors</a><a id="Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Vectors" title="Permalink"></a></h2><p>In Julia, vectors are a fundamental data structure used to store and manipulate collections of values. A vector is a one-dimensional array that can store elements of the same type (e.g., integers, floating-point numbers, or strings). Vectors are useful for representing and processing sequences of data, such as time series, feature vectors, or lists of names.</p><p>Show How to Create, Access, and Manipulate Vectors in Julia</p><p>To create a vector in Julia, you can use square brackets [] and separate the elements by commas. For example, to create a vector of integers, you would write:</p><pre><code class="language-julia hljs">integer_vector = [1, 2, 3, 4, 5]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Int64}:
 1
 2
 3
 4
 5</code></pre><p>You can access elements of a vector by specifying the index in square brackets. Note that Julia uses 1-based indexing, which means the first element has an index of 1:</p><pre><code class="language-julia hljs">first_element = integer_vector[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><p>You can also assign a new value to an element of a vector by specifying the index in square brackets and using the assignment operator:</p><pre><code class="language-julia hljs">integer_vector[1] = 10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10</code></pre><p>However, you cannot assign a new value to an element of a vector if the vector is of a fixed size. For example, if you try to assign a value to index 6 you will get an <code>BoundsError</code>. To add a new element to a vector, you can use the <code>push!</code> function:</p><pre><code class="language-julia hljs">push!(integer_vector, 6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Int64}:
 10
  2
  3
  4
  5
  6</code></pre><p>Notice the exclamation mark at the end of the function name. This is a convention in Julia that indicates that the function mutates its arguments. This means that the function modifies the original data passed as an argument instead of creating a new copy of the data.</p><p>This will already help you to predict the behavior of the <code>pop!</code> function:</p><pre><code class="language-julia hljs">last_element = pop!(integer_vector)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6</code></pre><p>Lets create two vectors and see what we can do with them:</p><pre><code class="language-julia hljs">vector1 = [1, 2, 3]
vector2 = [4, 5, 6]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 4
 5
 6</code></pre><p>When you use standard arithmetic operators (+, -) on vectors, Julia performs element-wise operations.</p><pre><code class="language-julia hljs">added_vectors = vector1 + vector2
subtracted_vectors = vector1 - vector2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 -3
 -3
 -3</code></pre><p>Scalar multiplication and division using the standard arithmetic operators (*, /):</p><pre><code class="language-julia hljs">multiplied_vector = 2 * vector1
divided_vector = vector1 / 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 0.5
 1.0
 1.5</code></pre><p>Vectors can be concetenated with the <code>vcat</code> function or the <code>;</code> operator:</p><pre><code class="language-julia hljs">concatenated_vector = vcat(vector1, vector2)
concatenated_vector = [vector1; vector2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{Int64}:
 1
 2
 3
 4
 5
 6</code></pre><p>However, when we want to multiply two vectors like this:</p><pre><code class="language- hljs">multiplied_vectors = vector1 * vector2</code></pre><p>We get a <code>MethodError</code> because the <code>*</code> operator is not defined for <code>Vector</code>s.</p><p>Now, it depends on what we mean when we want to multiply two vectors. If we want to perform an element-wise multiplication, we need to use the broadcast <code>.</code> operator:</p><pre><code class="language-julia hljs">vector = [1, 2, 3]
squared_vector = vector .* 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Int64}:
 2
 4
 6</code></pre><p>However, maybe you want to perform the dot product, that is related to matrix multiplication. It is also known as the scalar product, because it always returns a single number, i.e., a scalar. We can do this with the <code>dot</code> function or the <code>⋅</code> operator:</p><pre><code class="language- hljs">dot_product = dot(vector1, vector2)
dot_product = vector1 ⋅ vector2</code></pre><p>Now, at last we can transpose a vector with the <code>transpose</code> function or the <code>&#39;</code> operator:</p><pre><code class="language-julia hljs">transposed_vector = transpose(vector)
transposed_vector = vector&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×3 adjoint(::Vector{Int64}) with eltype Int64:
 1  2  3</code></pre><p>Equipped with the transpose operator <code>&#39;</code>, we can now multiply two vectors:</p><pre><code class="language-julia hljs">dot_product = vector1&#39; * vector2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32</code></pre><p>Mathematically, this is the same as the dot product!</p><p>Another important concept before we move on is the concept of sequences in Julia.</p><p>In programming, sequences are ordered collections of elements, typically used to represent a series of values or data points. Sequences are essential in various applications, such as iterating through data, generating series of numbers, and organizing data in specific orders.</p><p>In Julia, sequences can be created using ranges and comprehensions. Ranges represent a series of evenly spaced values and can be created using the colon operator <code>:</code> or the <code>range</code> function.</p><p>For example, you can create a range of integers from 1 to 10:</p><pre><code class="language-julia hljs">integer_sequence = 1:10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1:10</code></pre><p>To create a range with a specific step size, you can use the following syntax:</p><pre><code class="language-julia hljs">even_sequence = 2:2:10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2:2:10</code></pre><p>To convert a sequence to a vector, you can use the collect function:</p><pre><code class="language-julia hljs">integer_vector = collect(integer_sequence)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10</code></pre><h2 id="Arrays"><a class="docs-heading-anchor" href="#Arrays">Arrays</a><a id="Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays" title="Permalink"></a></h2><p>Without going too much into the details, it is important to know about the concept of arrays in Julia.</p><p>Arrays are a fundamental data structure in Julia that can be used to represent and manipulate multi-dimensional collections of values. Vectors and matrices are special cases of arrays, where vectors are one-dimensional arrays and matrices are two-dimensional arrays. Arrays can have more than two dimensions, allowing you to work with higher-dimensional data structures in a consistent and efficient way.</p><p>The concept of arrays generalizes vectors and matrices by extending their properties and operations to multiple dimensions. This means that most of the functions and operations you have learned for vectors and matrices can be applied to arrays with higher dimensions as well.</p><h3 id="Exercises-3"><a class="docs-heading-anchor" href="#Exercises-3">Exercises</a><a class="docs-heading-anchor-permalink" href="#Exercises-3" title="Permalink"></a></h3><ol><li>Create a vector of strings and concatenate it with another vector of strings.</li><li>Create a vector and perform an element-wise square of it.</li><li>Create another vector and calculate the scalar product with the first vector in the way you like.</li><li>Read out an index, set an index, append an element, and pop an element from a vector.</li></ol><p>TODO: Solutions.</p><details>
<summary>Show solution</summary>
<br><div class="admonition is-success"><header class="admonition-header">Solution</header><div class="admonition-body"><pre><code class="language-julia hljs">x = 456
y = &quot;another solutions I have to do&quot;</code></pre></div></div></details><h1 id="Matrices"><a class="docs-heading-anchor" href="#Matrices">Matrices</a><a id="Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Matrices" title="Permalink"></a></h1><p>In Julia, matrices are a fundamental data structure used to store and manipulate two-dimensional arrays of values. A matrix is a rectangular grid of elements, organized into rows and columns, where each element can be accessed by its row and column indices. Matrices are useful for representing and processing structured data, such as images, tables, or linear systems of equations.</p><p>To create a <code>Matrix</code> in Julia, you can use square brackets <code>[]</code> and separate the elements within each row by spaces or commas, and separate the rows by semicolons <code>;</code>. For example, to create a square matrix of integers, you would write:</p><pre><code class="language-julia hljs">square_matrix = [1 2 3; 4 5 6; 7 8 9]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Int64}:
 1  2  3
 4  5  6
 7  8  9</code></pre><p>You can access elements of a matrix by specifying the row and column indices in square brackets, separated by a comma. Note that Julia uses 1-based indexing, which means the first row and column have an index of 1:</p><pre><code class="language- hljs">upper_left_element = integer_matrix[1, 1]
lower_right_element = integer_matrix[3, 3]</code></pre><p>As you can see, many things are the same as with vectors, which is not surprising, since vectors are just 1-dimensional matrices.</p><p>Lets define a 2x3 <code>Matrix</code> ...</p><pre><code class="language-julia hljs">non_square_matrix = [1 2 3; 4 5 6]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 Matrix{Int64}:
 1  2  3
 4  5  6</code></pre><p>... and transpose it with the <code>transpose</code> function or the <code>&#39;</code> operator:</p><pre><code class="language-julia hljs">transposed_matrix = transpose(non_square_matrix)
transposed_matrix = non_square_matrix&#39;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 adjoint(::Matrix{Int64}) with eltype Int64:
 1  4
 2  5
 3  6</code></pre><p>Let&#39;s create two matrices and see what we can do with them:</p><pre><code class="language-julia hljs">matrix1 = [1 2; 3 4]
matrix2 = [5 6; 7 8]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Int64}:
 5  6
 7  8</code></pre><p>We already know from the chapter about <code>Vector</code>s that we can use the vcat function or semicolon <code>;</code> for vertical concatenation:</p><pre><code class="language-julia hljs">vertically_concatenated_matrix = vcat(matrix1, matrix2)  # Returns [1 2; 3 4; 5 6; 7 8]
vertically_concatenated_matrix = [matrix1; matrix2]      # Also returns [1 2; 3 4; 5 6; 7 8]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×2 Matrix{Int64}:
 1  2
 3  4
 5  6
 7  8</code></pre><p>Concatenate two matrices horizontally using the hcat function or space <code></code> :</p><pre><code class="language-julia hljs">concatenated_matrix = hcat(matrix1, matrix2)
concatenated_matrix = [matrix1 matrix2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×4 Matrix{Int64}:
 1  2  5  6
 3  4  7  8</code></pre><h2 id="Exercises-4"><a class="docs-heading-anchor" href="#Exercises-4">Exercises</a><a class="docs-heading-anchor-permalink" href="#Exercises-4" title="Permalink"></a></h2><ol><li>Define two square matrices and add and subtract them with each other.</li><li>Perform an element-wise multiplication of two matrices and then a matrix multiplication.</li><li>Write a vector with spaces, e.g.,: [1 2 3]. Is that really a vector?</li><li>Find out what else you can do with matrices by writing <code>methodswith(Matrix)</code> in the REPL.</li><li>Look into the documentation of <code>?something</code> you are interested in, then try it out in the REPL.</li></ol><h1 id="Control-Flow"><a class="docs-heading-anchor" href="#Control-Flow">Control Flow</a><a id="Control-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Control-Flow" title="Permalink"></a></h1><p>Control flow refers to the order in which statements or instructions are executed in a program. It is an essential concept in programming, as it allows you to create more dynamic and flexible code. Two fundamental control flow structures are loops and conditional statements. Loops allow you to repeat a block of code multiple times, while conditional statements enable you to execute a block of code only if certain conditions are met.</p><h2 id="For-Loops"><a class="docs-heading-anchor" href="#For-Loops">For Loops</a><a id="For-Loops-1"></a><a class="docs-heading-anchor-permalink" href="#For-Loops" title="Permalink"></a></h2><p>For loops in Julia are used to iterate over a range of values or the elements of a collection, such as an array or a tuple. The syntax for a for loop is as follows:</p><pre><code class="language- hljs">for variable in collection
    # Code to be executed for each value in the collection
end</code></pre><p>For example:</p><pre><code class="language-julia hljs">for i in 1:5
    println(i^2)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1
4
9
16
25</code></pre><p>If statements in Julia are used to execute a block of code only if a specific condition is met. The syntax for an <code>if</code> statement is as follows:</p><pre><code class="language- hljs">if condition
    # Code to be executed if the condition is true
end</code></pre><p>You can also use <code>elseif</code> and <code>else</code> to test multiple conditions:</p><pre><code class="language- hljs">if condition1
    # Code to be executed if condition1 is true
elseif condition2
    # Code to be executed if condition1 is false and condition2 is true
else
    # Code to be executed if both condition1 and condition2 are false
end</code></pre><p>For example, to check if a number is positive, negative, or zero:</p><pre><code class="language-julia hljs">number = -3

if number &gt; 0
    println(&quot;The number is positive&quot;)
elseif number &lt; 0
    println(&quot;The number is negative&quot;)
else
    println(&quot;The number is zero&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">The number is negative</code></pre><p>Let&#39;s remember what we learned about functions!</p><pre><code class="language-julia hljs">function classify_sign(number)
    if number &gt; 0
        println(&quot;The number is positive&quot;)
    elseif number &lt; 0
        println(&quot;The number is negative&quot;)
    else
        println(&quot;The number is zero&quot;)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">classify_sign (generic function with 1 method)</code></pre><p>Now we can use the function to classify any number we want:</p><pre><code class="language-julia hljs">classify_sign(3)
classify_sign(-3)
classify_sign(0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">The number is positive
The number is negative
The number is zero</code></pre><h2 id="Exercises-5"><a class="docs-heading-anchor" href="#Exercises-5">Exercises</a><a class="docs-heading-anchor-permalink" href="#Exercises-5" title="Permalink"></a></h2><ol><li>Write a for loop that prints the first 10 even numbers.</li><li>Create a 2x2 Matrix and print out the value of each index. Tip: use the <code>length</code> function.</li><li>Write a nested loop with <code>i</code> and <code>j</code> and add each index if both are equal and prints the result.</li><li>Create a 3-dimension and 4-dimensional array and call <code>size</code> and <code>length</code> on them.</li></ol><p>TODO: Solutions.</p><details>
<summary>Show solution</summary>
<br><div class="admonition is-success"><header class="admonition-header">Solution</header><div class="admonition-body"><pre><code class="language-julia hljs">x = 123
y = &quot;another solutions I have to do&quot;</code></pre></div></div></details></article><nav class="docs-footer"><p class="footer-message">Got a question? Something confuses you? <a href="https://github.com/formal-methods-mpi/Workshop.jl/issues/new">Don&#39;t hesitate to open an issue to ask for help!</a></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 25 April 2023 19:37">Tuesday 25 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
