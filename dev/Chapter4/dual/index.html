<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Automatic Differentiation · A fresh approach to scientific computing</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://formal-methods-mpi.github.io/Workshop.jl/Chapter4/dual/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">A fresh approach to scientific computing</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../Chapter0/workflow/">Chapter 0: Workflow</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Chapter 1: Syntax</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Chapter1/syntax/">Syntax</a></li><li><a class="tocitem" href="../../Chapter1/exercise/">Exercise</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Chapter 2: Types</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Chapter2/types/">Types</a></li><li><a class="tocitem" href="../../Chapter2/exercise/">Exercise</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Chapter 3: Multiple Dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Chapter3/dispatch/">Methods</a></li><li><a class="tocitem" href="../../Chapter3/exercise/">Exercise</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Chapter 4: Exercises</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Automatic Differentiation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Chapter 4: Exercises</a></li><li class="is-active"><a href>Automatic Differentiation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Automatic Differentiation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aaronpeikert/Workshop.jl/blob/main/docs/src/Chapter4/dual.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Automatic-Differentiation"><a class="docs-heading-anchor" href="#Automatic-Differentiation">Automatic Differentiation</a><a id="Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation" title="Permalink"></a></h1><p>Obtaining function derivatives is central in many areas of scientific computing. For example, in numerical optimization, we often need derivatives to find the minimum of a function (maximum likelihood estimation, neural networks, ...). However, deriving derivatives by hand can be quite tedious, especially if you work with frequently changing functions. As numerical differentiation is computationally quite expensive, automatic differentiation libraries have been developed. For example, most Deep Learning libraries employ a form of automatic differentiation called &quot;backpropagation&quot;. In this example, we will implement one form of automatic differentiation, called &quot;Forward mode AD&quot;.</p><p>To do so, we heavily rely on the chain rule:  suppose we have functions <span>$f: \mathbb{R} \to \mathbb{R}, \; g: \mathbb{R} \to \mathbb{R}$</span>. If we compose these functions, we can derive their derivative as </p><p class="math-container">\[(f(g(x)))&#39; = f&#39;(g(x)) \cdot g&#39;(x)\]</p><p>With a little bit abuse of notation, instead of defining two functions <span>$f$</span> and <span>$g$</span> we will write in the following <span>$x: \mathbb{R} \to \mathbb{R}$</span> as a function itself, so the chain rule becomes:</p><p class="math-container">\[(f(x))&#39; = f&#39;(x) \cdot x&#39;\]</p><p>Using the chain rule together with all the other basic differentiation rules you hopefully remember from high school gives:</p><p class="math-container">\[\begin{aligned}
(x + y)&#39; &amp;= x&#39; + y&#39; \\
(x - y)&#39; &amp;= x&#39; - y&#39; \\
(x \cdot y)&#39; &amp;= x&#39;\cdot y + x \cdot y&#39; \\
\left(\frac{1}{x}\right)&#39; &amp;= \frac{-x&#39;}{x^2} \\
\left(\frac{x}{y}\right)&#39; &amp;= \frac{x&#39; \cdot y - x \cdot y&#39;}{y^2} \\
(\log(x))&#39; &amp;= \frac{1}{x} \cdot x&#39; \\
(\sin(x))&#39; &amp;= \cos(x) \cdot x&#39; \\
(\cos(x))&#39; &amp;= -\sin(x) \cdot x&#39; \\
\left(x^k\right)&#39; &amp;= k \cdot x^{k-1} \cdot x&#39;
\end{aligned}\]</p><p>As most functions are compositions of basic functions (of course our list above is not exhaustive, but already sufficient for a lot of things), we can use the chain rule and the differentiation rules for those basic building blocks to &quot;propagate&quot; the derivative through more complex functions (just like we propagated the measurement error in the example in Chapter 3).</p><div class="admonition is-compat"><header class="admonition-header">Exercise</header><div class="admonition-body"><p>Define a struct <code>Dual</code> that stores a function value as well as it&#39;s derivative.</p></div></div><details>
<summary>show solution</summary>
<br><div class="admonition is-success"><header class="admonition-header">Solution</header><div class="admonition-body"><pre><code class="language-julia hljs">struct Dual
    x
    ∂x
end</code></pre></div></div></details><p><br/></p><div class="admonition is-compat"><header class="admonition-header">Exercise</header><div class="admonition-body"><p>Define methods for some of the basic functions described above: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>inv</code>, <code>log</code>, <code>sin</code>, <code>cos</code>, <code>^</code>. Remember that you have to import them from <code>Base</code>. Don&#39;t do all of them (it&#39;s tedious), just a few to get the idea.</p></div></div><details>
<summary>Hint</summary>
<br><div class="admonition is-compat"><header class="admonition-header">Hint</header><div class="admonition-body"><p>We could define the multiplication of two dual numbers as:</p><pre><code class="language-julia hljs">import Base: *
*(a::Dual, b::Dual) = Dual(a.x*b.x, a.∂x*b.x + a.x*b.∂x)</code></pre></div></div></details><p><br/></p><details>
<summary>show solution</summary>
<br><div class="admonition is-success"><header class="admonition-header">Solution</header><div class="admonition-body"><pre><code class="language-julia hljs">import Base: +, -, *, /, inv, log, sin, cos, ^

+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)
-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)
*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)
^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)
/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)
inv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))
log(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))
sin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)
cos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)</code></pre></div></div></details><p><br/>Of course we also wand to be able to have constants in our functions. To make our life a little bit easier, we can treat constant values (aka real numbers) as dual numbers with a derivative of 0. For this purpose, we define how to convert a real number into a dual number, and the relevant methods:</p><pre><code class="language-julia hljs">import Base: +, -, *, /, inv, log, sin, cos, ^

+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)
-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)
*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)
^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)
/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)
inv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))
log(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))
sin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)
cos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cos (generic function with 20 methods)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 23 April 2023 18:03">Sunday 23 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
