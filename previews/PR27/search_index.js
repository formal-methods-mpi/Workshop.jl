var documenterSearchIndex = {"docs":
[{"location":"2_syntax/syntax/#First-step","page":"First step","title":"First step","text":"","category":"section"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"Ah, excellent! You're all set up and ready to explore. Let's get started!","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"We will be working through a few examples to get you started. Because the Julia documentation already is very detailed about the language, we'll be focusing on the most important parts of the language. If you want to get a more complete overview of the language language or you have specific questions, we recommend you to read the Julia documentation. While doing the workshop you should ask us of course!","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"First we need to get acuainted with julias number types, variables, logical operators and functions. Because we thing it is boring if we just list all the operators and functions, we will use them in some examples. So let's get started","category":"page"},{"location":"2_syntax/syntax/#Assignment-function-definition-vectors-matrices-indices-control-flow-(for-/-if)-broadcasting","page":"First step","title":"Assignment + function definition + vectors + matrices + indices + control flow (for / if) + broadcasting","text":"","category":"section"},{"location":"2_syntax/syntax/#broadcast-square-over-array","page":"First step","title":"broadcast square over array","text":"","category":"section"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"x = 1","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"#unicode","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"#hello world","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"3 == 3.0     # true (integer and float comparison)\n3 != 3.0     # false (integer and float comparison)\n\"hello\" == \"hello\"   # true (string comparison)\n\"hello\" != \"world\"   # true (string comparison)\n\n4//5 < 0.75  # false (rational and float comparison)\n4//5 > 0.75  # true  (rational and float comparison)\n\"apple\" < \"banana\"   # true (string comparison based on lexicographic order)\n\"apple\" > \"banana\"   # false (string comparison based on lexicographic order)\n\n1//2 <= 0.5  # true (rational and float comparison)\n1//2 >= 0.5  # true (rational and float comparison)\n\"hello\" <= \"world\"   # true (string comparison based on lexicographic order)\n\"hello\" >= \"world\"   # false (string comparison based on lexicographic order)\n\n!true  # false (not operator)\n\n(3 == 3.0) && (\"apple\" < \"banana\")  # true (and operator)\n(3 != 3.0) || (4//5 < 0.75)         # false (or operator)\n\n(1//2 <= 0.5) && (\"hello\" >= \"world\")   # false (and operator with mixed types)\n(1//2 >= 0.5) || (\"hello\" <= \"world\")   # true (or operator with mixed types)\n\n!(\"hello\" == \"world\")               # true (not operator with string comparison)","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"==: Equality operator, checks whether two values are equal.\n!= or ≠: Inequality operator, checks whether two values are not equal.\n<: Less than operator, checks whether the left value is less than the right value.\n>: Greater than operator, checks whether the left value is greater than the right value.\n<= or ≤: Less than or equal to operator, checks whether the left value is less than or equal to the right value.\n>= or ≥: Greater than or equal to operator, checks whether the left value is greater than or equal to the right value.\n!: NOT operator, inverts the value of a boolean.\n&&: AND operator, returns true if both values are true.\n||: OR operator, returns true if at least one of the values is true.","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"You might be thinking, but how do I write that ≠ sign in Julia. \\ne<tab> will give you the ≠ sign. You can also use \\le<tab> for ≤ and \\ge<tab> for ≥.","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"You can use these also for variables by writing \\delta<tab> for δ and \\alpha<tab> for α.","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"δ = 2 - 1.3\nα = 3 * 4","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"You can already see that Julia easily handles different types of numbers. You can check their type with the typeof function.","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"typeof(δ)  # Float64\ntypeof(α)  # Int64","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"Creating functions in Julia is a straightforward process. To define a function, you can use the function keyword, followed by the function name, and enclose the function body in a block using the end keyword. By default, functions in Julia return the value of the last expression, which eliminates the need for an explicit return statement. However, it is a recommended practice to include a return statement to make it easier to understand what the function is returning. To evaluate an expression and include its result in a string, you can use the $ symbol within the string for interpolation.","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"function greet(name)\n    greeting = \"Hello, $(name)!\"\n    return greeting\nend","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"greet(\"Julia Explorer\")  # Output: Hello, Julia Explorer!","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"If we have a short function like this, we can also define it in a single line:","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"greet(name) = \"Hello, $(name)!\"","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"To better understand interpolation, let's consider another example. If we're interpolating a single variable, we don't need to use braces. But why did we do that in the previous example? Including braces helps Julia identify and resolve the variable more easily. Without braces, Julia would've produced an error stating that it can't find the variable name! and we would have had to add an additional whitespace. Additionally, braces are necessary when interpolating more complicated expressions, as in the next example:","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"x = 1`\ny = 2//3\nstring_output = \"The sum of $x and $y is $(x + y).\"","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"Awesome! Now lets look at control flow statements, such as if, for, while, and break and combine them with what we've learned so far:","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"function check_x(x)\n    if x < 5\n        println(\"x is less than 5\")\n    elseif x > 5\n        println(\"x is greater than 5\")\n    else\n        println(\"x is equal to 5\")\n    end\nend","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"check_x(10) # Output: x is greater than 5\ncheck_x(4//7)","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"naming, snakecase vs camelcase","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"You can see that Julia easily works with different types of numbers, even though you dont have to worry about them.","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"However, Julia will throw an error if we pass a complex number:","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"check_x(4+3im)","category":"page"},{"location":"2_syntax/syntax/#explain-sequences","page":"First step","title":"explain sequences","text":"","category":"section"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"function print_numbers(start, stop)\n    for i in start:stop\n        println(i)\n    end\nend","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"function print_numbers(x)\n    while x < 10\n        println(x)\n        x += 1\n    end\nend","category":"page"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"function print_numbers()\n    for i in 1:10\n        if i == 5\n            break\n        end\n        println(i)\n    end\nend","category":"page"},{"location":"2_syntax/syntax/#Resources","page":"First step","title":"Resources","text":"","category":"section"},{"location":"2_syntax/syntax/","page":"First step","title":"First step","text":"Julia Docs - Integers and Floating-Point Numbers Julia Docs - Rational and Complex Numbers Julia Docs - Mathematical Operations Julia Docs - Strings","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"using InteractiveUtils\n\nabstract type Pokemon end\nabstract type Normal <: Pokemon end\nabstract type Flying <: Pokemon end\nabstract type Electric <: Pokemon end\n\nstruct Pikachu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nstruct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_pikachu = Pikachu(\"Pika\", 135, 80, 110, 132)\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)","category":"page"},{"location":"4_dispatch/dispatch/#Multiple-Dispatch","page":"Theory","title":"Multiple Dispatch","text":"","category":"section"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"We will now approach the central topic of this workshop: multiple dispatch. In julia, functions can behave quite differently, depending on the type of their arguments. For example, let's take a look at the multiplication function *:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"a = 1.0\nb = 1.0\na * b","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"a = \"Hello \"\nb = \"World\"\na * b","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"a = rand(5, 5)\nb = rand(5, 5)\na * b","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"If we multiply two numbers together, we will get their product, if we multiply two strings together, they are concatenated, and if we multiply two arrays, we get a matrix product. So functions are able to specialise on the type of the input arguments. Every such specialisation we call a method of that function. We can for example take a look at all the methods for *:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"methods(*)\nnothing # hide","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"# 372 methods for generic function \"*\":\n[1] *(x::T, y::T) where T<:Union{Int128, UInt128} in Base at int.jl:976\n[2] *(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:88\n[3] *(x::T, y::T) where T<:Union{Float16, Float32, Float64} in Base at float.jl:385\n[4] *(s1::Union{AbstractChar, AbstractString}, ss::Union{AbstractChar, AbstractString}...) in Base at strings/basic.jl:260\n[5] *(d::Union{AbstractChar, AbstractString}, x::Missing) in Base at missing.jl:183\n[6] *(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigInt) in Base.GMP at gmp.jl:542\n[7] *(c::Union{Int16, Int32, Int64, Int8}, x::BigInt) in Base.GMP at gmp.jl:544\n[8] *(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigFloat) in Base.MPFR at mpfr.jl:398\n[9] *(c::Union{Int16, Int32, Int64, Int8}, x::BigFloat) in Base.MPFR at mpfr.jl:406\n[10] *(c::Union{Float16, Float32, Float64}, x::BigFloat) in Base.MPFR at mpfr.jl:414\n[11] *(A::StridedMatrix{T}, x::StridedVector{S}) where {T<:Union{Float32, Float64, ComplexF32, ComplexF64}, S<:Real} in LinearAlgebra at /usr/share/julia/stdlib/v1.8/LinearAlgebra/src/matmul.jl:49","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"We see there are quite a number of methods/specialisations available for the * function. To see the particular method that is used for a given combination of arguments, we call","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"@which a*b\nnothing #hide","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"*(A::Union{LinearAlgebra.Adjoint{var\"#s886\", <:StridedMatrix{T} where T}, LinearAlgebra.Transpose{var\"#s886\", <:StridedMatrix{T} where T}, StridedMatrix{var\"#s886\"}} where var\"#s886\"<:Union{Float32, Float64}, B::Union{LinearAlgebra.Adjoint{var\"#s885\", <:StridedMatrix{T} where T}, LinearAlgebra.Transpose{var\"#s885\", <:StridedMatrix{T} where T}, StridedMatrix{var\"#s885\"}} where var\"#s885\"<:Union{Float32, Float64}) in LinearAlgebra at /usr/share/julia/stdlib/v1.8/LinearAlgebra/src/matmul.jl:146","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"and are even able to strg+click on the link to directly take us to the method definition.","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"The crucial part is that methods don't have to be defined together with the function, but that instead we can add methods to existing functions. To add a method to a function from another module, we first import the function:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"import Base: *","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"and add a new method just like we would define a function","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"function *(a::SomeType, b::AnotherType)\n    ...\nend\n\n*(a::SomeType, b::AnotherType) = ...","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"but we specify on which input-type combination the method should be called (in the above pseudo-code, the method would be called every time we multipy two variables a and b, where a is of type SomeType and b of type AnotherType).","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"Let's practise this a bit. We return to our Pokemon example: suppose we would like to let pokemon fight against each other. As you maybe know, depending on the type of Pokemon (e.g., Normal, Fire, Flight, etc.), the attacks vary in their effectiveness. So let's define a function effectiveness that computes this for us. I will first define the generic fallback defintion, that is used every time there is no special interaction between the types of pokemon fighting:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"effectiveness(attacker::Pokemon, defender::Pokemon) = 1.0","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"Calling this function on our previously defined Pokemon, we get","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"effectiveness(my_pikachu, my_crobat)","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"However, the rules of Pokemon tell us that we should have the following interactions between the types we defined:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"↓att/def→ Electric Flying Normal\nElectric 0.5 2 1\nFlying 0.5 1 1\nNormal 1 1 1","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"compat: Exercise\nDefine the missing methods for the effectiveness function according to the table.","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"tip: Solution\neffectiveness(attacker::Electric, defender::Electric) = 0.5\neffectiveness(attacker::Electric, defender::Flying) = 2.0\neffectiveness(attacker::Flying, defender::Electric) = 0.5\n\neffectiveness(my_pikachu, my_crobat)","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"    effectiveness(attacker::Electric, defender::Electric) = 0.5 #hide\n    effectiveness(attacker::Electric, defender::Flying) = 2.0 #hide\n    effectiveness(attacker::Flying, defender::Electric) = 0.5 #hide\n\n    effectiveness(my_pikachu, my_crobat) #hide","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"\nWe only have to define 3 methods, because for all other cases, our generic fallback works correctly. We also see, that our function now correctly works for our Pikachu and Crobat, so we succesfully altered the functions behaviour to correctly work on our types.","category":"page"},{"location":"additional-resources/#Books","page":"-","title":"Books","text":"","category":"section"},{"location":"additional-resources/","page":"-","title":"-","text":"Julia Data Science - Free Online Book\nHands on Design Patterns and Best Practices with Julia - Great but not free","category":"page"},{"location":"additional-resources/#Cheatsheets","page":"-","title":"Cheatsheets","text":"","category":"section"},{"location":"additional-resources/","page":"-","title":"-","text":"Julia Overview\nMATLAB–Python–Julia comparison\nJulia-R comparison\nJulia-Python-R comparison\nNoteworthy differences to other Languages\nData Wrangling with DataFrames.jl","category":"page"},{"location":"5_advanced/intro/#Advanced-Materials","page":"Introduction","title":"Advanced Materials","text":"","category":"section"},{"location":"5_advanced/intro/","page":"Introduction","title":"Introduction","text":"This chapter contains some advanced materials and exercises. You should do it only after you finished the rest of the workshop. You can do them in any order, just pick something you are interested in.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"using InteractiveUtils\n\nstruct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend\n\n±(val, err) = Measurement(val, err)","category":"page"},{"location":"4_dispatch/exercise/#Exercise:-Combining-Linear-Regression-and-Measurements","page":"Exercise","title":"Exercise: Combining Linear Regression and Measurements","text":"","category":"section"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Let's return to our example from the previous chapter, where we defined a new type called Measurement to store a measurement and it's measurement error. We will now define appropriate methods for this type.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Let's first take a look at addition: if we add two measurements, a pm b and c pm d, we will get a new measurement","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"(a pm b) + (c pm d) = (a + c) pm (b + d)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"That is, we add the measured values and the error terms separately.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine a method for the addition of two measurements. Hint: recall that functions from other modules (like + from Base) have to be imported before you can define a new method for them.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nimport Base: +\n+(x::Measurement, y::Measurement) = Measurement(x.value + y.value, x.error + y.error)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"import Base: + #hide\n+(x::Measurement, y::Measurement) = Measurement(x.value + y.value, x.error + y.error) #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"\nWe can now add measurements together:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"m1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34\n\nm1 + m2","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Work's like a charm! Subtraction works similarly, so I will define this method for you:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"import Base: -\n-(x::Measurement, y::Measurement) = Measurement(x.value - y.value, x.error + y.error)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"To make working with our Measurement type a bit more aesthetic, we can even define a new method for Base.show that defines how our type is printed to the REPL:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"import Base: show\n\nfunction show(io::IO, m::Measurement)\n    value_as_string = string(round(m.value, digits = 2))\n    error_as_string = string(round(m.error, digits = 2))\n    print(io, value_as_string*\" ± \"*error_as_string)\nend\n\nm1","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"But let's get back to more serious business: The next thing we need is to be able to add measurements and real numbers together. We can think of real numbers as measurements without error, so adding a measurement (a pm b) and a real number c should yield","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"(a pm b) + c = (a + c) pm b ","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nAdd methods for the addition of measurements and real numbers. Hint: real numbers are denoted by the type Real.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\n+(a::Real, b::Measurement) = Measurement(a + b.value, b.error)\n+(a::Measurement, b::Real) = b + a\nm1 + 3.53","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"+(a::Real, b::Measurement) = Measurement(a + b.value, b.error) #hide\n+(a::Measurement, b::Real) = b + a #hide\nm1 + 3.53 #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"\nOkay, to spare you some time, I will define some last methods we need: subtraction and multiplication of real numbers and measurements.  Subtraction works just like addition, and for multiplication we see that","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"c cdot (a pm b) = ca pm cb","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"-(x::Measurement, y::Real) = Measurement(x.value - y, x.error)\n-(x::Real, y::Measurement) = Measurement(x - y.value, y.error)\n\nimport Base: *\n*(x::Measurement, y::Real) = Measurement(x.value*y, abs(x.error*y))\n*(x::Real, y::Measurement) = y*x","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Let's see if it all works as planned:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"m1 + m2\n9.34 + m1\nm2 + 4.52\n3.5 * m2\nm2 * 3.5","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Now for the fun part:  In the exercise to the first chapter, we tried to predict income from years of education with the help of linear regression. Let's simulate some data again:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\nnothing #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"This time, let's asume we observed education with some measurement error:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"x = Measurement.(x, 2*randn(20))","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"But what happens when we us the education data with measurement error to predict income? Let's find out! We defined our prediction function as","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"function predict(x, α, β)\n    y = α .+ β*x\n    return y\nend\nnothing #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"and if we plug in the values for education with measurement error, we achieve","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"predict(x, 1000, 300)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"a prediction of income with the respective measurement error.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Hopefully, this serves a a nice illustration of what multiple dispatch together with julias type system is able to achieve. When you wrote the predict function at the beginning of this workshop, you probably had no idea what multiple dispatch even is. But because we are able to define methods for important operations (like *, +), we can use any function or algorithmn that is composed of these operations. This is a very powerful idea that allows for great extensibility and interaperability of different packages. If you don't believe me, imagine somebody has written an R package for linear regression. Now you are in the situation that you have to deal with measurement error. I believe it would be impossible to get the published R package to work with measurement error without rewriting the whole package.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Similarly, if you think about our pokemon example from the beginning: If we would like to add more types of pokemon, we just have to define the types (Water, Fire, etc.) and the relevant methods for our functions (effectiveness). Of course, the code we wrote in the pokemon example is rather limited, but this translates seamlessly to complicated packages with more functionality.","category":"page"},{"location":"2_syntax/exercise/#Exercise:-Linear-Regression","page":"Exercise","title":"Exercise: Linear Regression","text":"","category":"section"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"We will finish this chapter with an exercise that makes use of some of the basic syntax elements described before. Our goal is to implement linear regression. During the course of the workshop, we will come back to this example several times. Let's first have a look at what linear regression is: Suppose you observe the two variables education (in years) and income (per month in dollar), and you want to predict a persons income based on their education. One way to do this is linear regression. Suppose we conducted a study and observed the following data points:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)\n\nusing Plots\ndefault(legend = false)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\n\nplot(x, y; seriestype=:scatter, xlabel = \"Education\", ylabel = \"Income\")\nsavefig(\"data.png\")","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"(Image: data)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"On the x-axis, you see the years of education, and on the y-axis you see the monthly income. The task of linear regression is to find a straight line that best describes this relationship:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"Plots.abline!(β, α)\nsavefig(\"lr.png\")","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"(Image: lr)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"As you may recal from university, school, or learn just now, a straight line is mathematically described by y = alpha + beta x, where in our case, y corresponds to income and x to years of education.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nWrite a function predict that takes x, α and β as inputs and returns the predicted value for y.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction predict(x, α, β)\n    y = α .+ β*x\n    return y\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"function predict(x, α, β)\n    y = α .+ β*x\n    return y\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"Let's simulate some data for the task at hand. First, we load the Random package (a julia package for random number generation) and set a seed (to make our experiments reproducible):","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"Next, we generate some random values for years of education:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"x = 10 .+ 3*randn(20)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"This produces a vector of 20 values with 10 years of education as the average, and some normally distributed random variation.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nUse your previously defined function predict to generate some values for income (y) with α = 1000, β = 300","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\ny = predict(x, 1000, 300)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"y = predict(x, 1000, 300) #hide","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n Since in reality, income does not perfectly depend on education, but there is some random variation, we add this random variation to y:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"y += 500*randn(20)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"And viola! We have some data to work with.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"In reality of course, we don't know the values for alpha and beta, but we have to estimate them from the data. To do so, we first need some indication of how good a certain combination of values works for our data. Usually, we use the sum of squared errors for this task:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"sum_i=1^n (haty_i - y_i)^2","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"So we go through all of our n data points (i = 1, ..., n) and for each of those data points we compute the squared distance between the prediction, haty_i, and the value we observed in reality, y_i.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine a function squared_error that takes a vector of predicted values and a vector of observed values as input and computes the sum of squared errors between them.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction squared_error(y, ŷ)\n    error = 0.0\n    for i in eachindex(y)\n        error += (y[i] - ŷ[i])^2\n    end\n    return error\nendor, a bit shorter using broadcasting:function squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"function squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nUsing your previously defined predict and squared_error functions to define a function squared_error_regression that takes as input values for α, β, x and y and returns as output the squared error between predictions and observed values. Then, use this function to compute the squared error for the parameter values 1. β = 100, α = 200 and 2. β = 300, α = 1000","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction squared_error_regression(α, β, y, x)\n    return squared_error(y, predict(x, α, β))\nend\n\nsquared_error_regression(200, 100, y, x)\nsquared_error_regression(1000, 300, y, x)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"function squared_error_regression(α, β, y, x) #hide\n    return squared_error(y, predict(x, α, β)) #hide\nend #hide\n #hide\nsquared_error_regression(200, 100, y, x) #hide","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"squared_error_regression(1000, 300, y, x) #hide","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n You should see that the error corresponding to the true parameters we used to simulate the data is much lower.","category":"page"},{"location":"5_advanced/workflow/#Use-Juliaup-for-Julia-Version-Management","page":"Workflow","title":"Use Juliaup for Julia Version Management","text":"","category":"section"},{"location":"5_advanced/workflow/","page":"Workflow","title":"Workflow","text":"If you're comfortable using the shell and already have some experience with the terminal, you may want to install Juliaup, a powerful cross-platform Julia installer. It helps you to manage multiple versions of the Julia programming language and you'll be notified when a new version becomes available. To install Juliaup, check out the Juliaup GitHub page. After the installation just execute juliaup add release in your terminal and you're ready to go.","category":"page"},{"location":"1_workflow/usage/#Working-with-Julia-in-VSCode","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"We will now learn how to use Julia in Visual Studio Code (VSCode) through some examples, so let's tackle everything together. If you feel slightly overwhelmed at first, don't worry — that's perfectly natural. It takes time to become familiar with a tool like VSCode.","category":"page"},{"location":"1_workflow/usage/#Create-a-folder-for-the-workshop","page":"Working with Julia in VSCode","title":"Create a folder for the workshop","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"First, we'll want to create a dedicated folder for our workshop. VSCode isn't particularly friendly when it comes to navigating files/folders. So don't try to use VSCode for that. Instead, we will use our operating system for that, i.e., just use your Explorer/Finder and create a folder in a location that makes sense to you. Once you've done that, you can open the folder in VSCode by navigating to the Menu Bar and selecting File > Open Folder and then selecting the folder you just created.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Next, let's create a new file within our workshop folder. To do this, right-click within the folder's file explorer in VSCode, and select \"New File.\" Name this file introduction.jl and then open it by double-clicking on the file name. In this file, write the following code:","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"println(\"Hello, Julia!\")","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Now, we'll execute this code using the Command Palette. To open the Command Palette, press Ctrl+Shift+P (Windows/Linux) or Cmd+Shift+P (Mac). In the Command Palette search bar, type \"execute,\" and then look for the option \"Julia: Execute Code in REPL and Move\" Take note what the displayed shortcut for executing code in the REPL is - you can use this shortcut in the the future to execute a line of code from your script. Leave the command palette by clicking on the background, click on the line of code you just worte, and hit the shortcut to execute it. The code you've written should be executed, displaying \"Hello, Julia!\" in the REPL window that opens up at the bottom of VSCode.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Great! You've just executed your first line of Julia in VSCode!","category":"page"},{"location":"1_workflow/usage/#The-Julia-REPL","page":"Working with Julia in VSCode","title":"The Julia REPL","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"The Julia REPL (Read-Eval-Print Loop) is an interactive and modern command-line interface for the Julia programming language. It allows you to enter Julia expressions, execute them, and see the results immediately. This makes the REPL a great place to experiment with Julia, test ideas, get help, and much more.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"The REPL has several differend modes:","category":"page"},{"location":"1_workflow/usage/#Julia-mode","page":"Working with Julia in VSCode","title":"Julia mode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"This is the default mode when you start the REPL. Here, you can enter and execute Julia expressions. To return to Julia mode from any other mode, press Backspace.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"compat: Exercise\nAdd two numbers in the REPL.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"tip: Solution\njulia> 3+4\n7","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"</details>","category":"page"},{"location":"1_workflow/usage/#Help-mode","page":"Working with Julia in VSCode","title":"Help mode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"To access Help mode, press ?. In this mode, you can search for documentation and information about various Julia functions, types, and keywords.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"compat: Exercise\nTo find information on the println function, enter Help mode by pressing ?. Once in Help mode, simply type println and press Enter to retrieve the relevant documentation.\nLook for an alternative print function by entering \"print\" (with quotation marks) in the search field. Julia will subsequently provide a list of definitions where the string \"print\" appears in the associated documentation.","category":"page"},{"location":"1_workflow/usage/#Shell-mode","page":"Working with Julia in VSCode","title":"Shell mode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"To enter Shell mode, press ;. In this mode, you can execute shell commands (e.g., ls, cd, mkdir) as you would in your operating system's command prompt or terminal. This allows you to perform file and directory operations, or to start a command-line interface without leaving the Julia REPL.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"compat: Exercise\nEnter Shell mode by pressing ;. List the files in the current directory with ls.\nCreate another Julia file in the current directory with touch chapter1.jl.","category":"page"},{"location":"1_workflow/usage/#Package-mode","page":"Working with Julia in VSCode","title":"Package mode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Access Package mode by pressing ]. This mode is dedicated to managing Julia packages using the built-in package manager, Pkg. In Package mode, you can add, update, remove, and list installed packages, among other tasks.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"compat: Exercise\nEnter Package mode by pressing ]. Add the Example package: add Example.\nList the installed packages: status.\nDiscover what else you can type in Package mode by entering help or ?.","category":"page"},{"location":"1_workflow/usage/#Summary","page":"Working with Julia in VSCode","title":"Summary","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"In this chapter, we created a folder for the workshop, executed our first Julia code, and explored the various modes of the Julia REPL, including Julia mode, Help mode, Shell mode, and Package mode.","category":"page"},{"location":"abstract/","page":"-","title":"-","text":"Julia is a high-level dynamic programming language designed for numerical and scientific computing, data analysis, machine learning, and more. Julia's user-friendly interface, resembling popular languages like R, Python, and Matlab, makes it easily accessible for learners. Its focus on performance, however, enables computational speeds that often rival, or even surpass, those of low-level languages such as C or Fortran. Therefore, Julia is an ideal choice for large-scale data analysis and other computationally intensive tasks, as it can be orders of magnitude faster than R or Python. In this workshop, we will introduce you to the basics of Julia and the key features that set it apart from other languages.","category":"page"},{"location":"abstract/","page":"-","title":"-","text":"This workshop is designed for R/Python/Matlab users interested in learning a new programming language or wanting to improve their data analysis and scientific computing skills. No prior experience with Julia is required, but understanding a programming language is recommended.","category":"page"},{"location":"0_preparation/preparation/#Setup","page":"Setup","title":"Setup","text":"","category":"section"},{"location":"0_preparation/preparation/#Installing-Julia","page":"Setup","title":"Installing Julia","text":"","category":"section"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"Before we begin working with Julia, it's essential to have the language properly installed on your computer. Follow the steps below to install Julia:","category":"page"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"Go to the official Julia Website and navigate to the \"Downloads\" section.\nChoose the current stable release for your operating system (Windows, macOS, or Linux), download it, and install it.\nTo verify the installation, open a terminal and execute the julia command. This should launch Julia, indicating it is successfully installed on your system.","category":"page"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"Now that you have Julia installed, we can proceed to set up your development environment.","category":"page"},{"location":"0_preparation/preparation/#Installing-Visual-Studio-Code-(VSCode)","page":"Setup","title":"Installing Visual Studio Code (VSCode)","text":"","category":"section"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"Visual Studio Code (VSCode) is a popular and versatile integrated development environment (IDE) that offers excellent support for Julia, making it our recommended choice for this workshop.","category":"page"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"Download the installer.\nOnce the download is complete, locate the installer file and run it. Follow the prompts and instructions to install VSCode.\nAfter the installation is complete, open VSCode.","category":"page"},{"location":"0_preparation/preparation/#Installing-Julia-extension-for-VSCode","page":"Setup","title":"Installing Julia extension for VSCode","text":"","category":"section"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"Now that you have VSCode installed and open, you'll need to add the Julia extension. Follow these steps:","category":"page"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"Open the Extensions view: Click on the square icon on the left-hand sidebar (or press Ctrl+Shift+X / Cmd+Shift+X) to open the Extensions view.\nSearch for the Julia extension: In the Extensions view, use the search bar at the top to search for \"Julia\" and select the extension called \"Julia\" from the author julialang.\nClick on the \"Install\" button on the top of the page.","category":"page"},{"location":"0_preparation/preparation/","page":"Setup","title":"Setup","text":"You have now successfully set up VSCode with Julia support, and are ready for the workshop!","category":"page"},{"location":"2_syntax/foundations/#Foundations","page":"Theory","title":"Foundations","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Welcome to the next chapter! We hope that you made it through the setup part without too many headaches. Please don't hesitate to ask us any questions or provide feedback on what you liked and didn't like or thought was too easy or too hard. Your input is always welcome and appreciated!","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"We are now ready to dive into the foundations of the Julia language.","category":"page"},{"location":"2_syntax/foundations/#Variable-assignment","page":"Theory","title":"Variable assignment","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"In Julia, variables are used to store data and represent values in your program. Variables have a name and are assigned a value using the assignment operator =. Julia supports both regular (ASCII) variable names (like alpha) and Unicode variable names (like α).","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Regular variables are named using alphanumeric characters and underscores, starting with a letter or underscore.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"x = 1\nmy_variable = \"awesome\"","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Unicode variables allow you to use a wider range of characters, including mathematical symbols, Greek letters, and other special characters. To create a Unicode variable, type a backslash followed by the Unicode character name, and then press the Tab key to convert it into the corresponding Unicode symbol. For example, type \\alpha and then press Tab to create the α variable.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"α = 0.05\nβ₁ = 1.2\nΔt = 0.01","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"compat: Exercise\nAssign the integer value 42 to a variable named theanswerto_life.\nAssign the string \"Julia is fun!\" to a variable named yay.\nAssign the value of 1 + √2 divided by 2 to the variable φ (phi). Remember to use the Unicode character: type \\phi or \\sqrt and press Tab to convert it.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"tip: Solution\nthe_answer_to_life = 42\nyay = \"Julia is fun!\"\nϕ = (1 + √2)/2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"the_answer_to_life = 42\nyay = \"Julia is fun!\"\nϕ = (1 + sqrt(2))/2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"2_syntax/foundations/#Functions","page":"Theory","title":"Functions","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Excellent! Now that you have an understanding of variables and the use of unicode symbols, let's dive into the topic of functions.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"In programming, functions are reusable blocks of code that serve a specific purpose. They play a crucial role in organizing and modularizing code, which in turn enhances its readability and maintainability. For instance, if you've written a chunk of code that performs a specific task or multiple tasks, it would be beneficial to break down the code into individual functions and give each a descriptive name. This approach makes your code more comprehensible and easier to work with. Functions also enable code reuse, minimizing redundancy and simplifying updates, which can save time and effort in the long run.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"The basic syntax for defining a function in Julia is as follows:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function function_name(argument1, argument2)\n    # function body\n    return output\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"The return keyword plays a vital role in specifying the value that a function should output. When no return statement is explicitly provided, the function will return the value of the last expression evaluated in the function body.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"However, it is generally good practice to include a return statement when defining functions using the function keyword, even if the function returns nothing. This approach helps to eliminate ambiguity and ensures that the function's expected output is clear to anyone who reads it.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function add(x, y)\n    return x + y\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can also define functions as:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function_name(argument1, argument2) = #function body","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"square(x) = x * x","category":"page"},{"location":"2_syntax/foundations/#Exercises","page":"Theory","title":"Exercises","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"compat: Exercise\nWrite a function called divide that takes two arguments and returns the result of dividing the first argument by the second.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"tip: Solution\nfunction divide(a, b)\n    return a/b\nend\n# or\ndivide(a, b) = a/b","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"    function divide(a, b)\n        return a/b\n    end\n    # or\n    divide(a, b) = a/b","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"2_syntax/foundations/#Vectors","page":"Theory","title":"Vectors","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"In Julia, vectors are a fundamental data structure used to store and manipulate collections of values. A vector is a one-dimensional array that can store elements. Vectors are useful for representing and processing sequences of data, such as time series, feature vectors, or lists of names.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"To create a vector in Julia, you can use square brackets [] and separate the elements by commas. For example, to create a vector of integers, you can write:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"integer_vector = [1, 2, 3, 4, 5]","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can access elements of a vector by specifying the index in square brackets. Note that Julia uses 1-based indexing, which means the first element has an index of 1:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"first_element = integer_vector[1]","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can also assign a new value to an element of a vector by specifying the index in square brackets and using the assignment operator:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"integer_vector[1] = 10\ninteger_vector","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"To add a new element to the end of a vector, you can use the push! function:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"push!(integer_vector, 6)","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Notice the exclamation mark at the end of the function name. This is a convention in Julia that indicates that the function mutates its arguments. This means that the function modifies the original data passed as an argument instead of creating a new copy of the data.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"This will already help you to predict the behavior of the pop! function:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"last_element = pop!(integer_vector)","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Lets create two vectors and see what we can do with them:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"vector1 = [1, 2, 3]\nvector2 = [4, 5, 6]","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"When you use standard arithmetic operators (+, -) on vectors, Julia performs element-wise operations.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"added_vectors = vector1 + vector2\nsubtracted_vectors = vector1 - vector2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Scalar multiplication and division using the standard arithmetic operators (*, /):","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"multiplied_vector = 2 * vector1\ndivided_vector = vector1 / 2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Vectors can be concetenated with the vcat function or the ; operator:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"concatenated_vector = vcat(vector1, vector2)\nconcatenated_vector = [vector1; vector2]","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"However, when we want to multiply two vectors like this:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"try  #hide\nmultiplied_vectors = vector1 * vector2\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"We get a MethodError because the * operator is not defined for Vectors.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Now, it depends on what we mean when we want to multiply two vectors. If we want to perform an element-wise multiplication, we need to use the broadcast . operator:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"vector1 .* vector2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"However, maybe you want to perform the dot product, that is related to matrix multiplication. It is also known as the scalar product, because it always returns a single number, i.e., a scalar. We can do this with the dot function or the ⋅ operator from the LinearAlgebra package:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"using LinearAlgebra\ndot_product = dot(vector1, vector2)\ndot_product = vector1 ⋅ vector2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Another important concept before we move on is the concept of sequences in Julia.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"In programming, sequences are ordered collections of elements, typically used to represent a series of values or data points. Sequences are essential in various applications, such as iterating through data, generating series of numbers, and organizing data in specific orders.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"In Julia, sequences can be created using ranges. They represent a series of evenly spaced values and can be created using the colon operator : or the range function.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example, you can create a range of integers from 1 to 10:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"integer_sequence = 1:10","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"To create a range with a specific step size, you can use the following syntax:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"even_sequence = 2:2:10","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"To convert a sequence to a vector, you can use the collect function:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"integer_vector = collect(integer_sequence)","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"compat: Exercises\nCreate a vector of numbers and perform an element-wise square.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"tip: Solution\na = [1 2 3]\na .^ 2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"a = [1 2 3]\na .^ 2","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"\n","category":"page"},{"location":"2_syntax/foundations/#Matrices","page":"Theory","title":"Matrices","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Matrices are a data structure used to store and manipulate two-dimensional arrays of values. A matrix is a rectangular grid of elements, organized into rows and columns, where each element can be accessed by its row and column indices.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"To create a Matrix in Julia, you can use square brackets [] and separate the elements within each row by spaces or commas, and separate the rows by semicolons ;. For example, to create a square matrix of integers, you would write:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"square_matrix = [1 2 3; 4 5 6; 7 8 9]","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can access elements of a matrix by specifying the row and column indices in square brackets, separated by a comma. Note that Julia uses 1-based indexing, which means the first row and column have an index of 1:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"upper_left_element = square_matrix[1, 1]\nlower_right_element = square_matrix[3, 3]","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"As you can see, things are very similar to vectors.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"compat: Exercises\nDefine two square matrices and add and subtract them to/from each other.\nPerform an element-wise multiplication of two matrices and then a matrix multiplication.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"tip: Solution\na = [1 2; 3 4]\nb = [π sin(1); -5 3]\na + b\na - b\na .* b\na * b","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"a = [1 2; 3 4]\nb = [π sin(1); -5 3]\na + b\na - b\na .* b\na * b","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"2_syntax/foundations/#Control-Flow","page":"Theory","title":"Control Flow","text":"","category":"section"},{"location":"2_syntax/foundations/#For-Loops","page":"Theory","title":"For Loops","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For loops in Julia are used to iterate over a range of values or the elements of a collection, such as an array or a tuple. The syntax for a for loop is as follows:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"for variable in collection\n    # Code to be executed for each value in the collection\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"for i in 1:5\n    println(i^2)\nend","category":"page"},{"location":"2_syntax/foundations/#Conditional-evaluation","page":"Theory","title":"Conditional evaluation","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"If-else statements are used to execute a block of code only if a specific condition is met. The syntax for an if statement is as follows:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"if condition\n    # Code to be executed if the condition is true\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can also use elseif and else to test multiple conditions:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"if condition1\n    # Code to be executed if condition1 is true\nelseif condition2\n    # Code to be executed if condition1 is false and condition2 is true\nelse\n    # Code to be executed if both condition1 and condition2 are false\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example, to check if a number is positive, negative, or zero:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"number = -3\n\nif number > 0\n    println(\"The number is positive\")\nelseif number < 0\n    println(\"The number is negative\")\nelse\n    println(\"The number is zero\")\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"compat: Exercise\nWrite a for loop that prints the first 10 even numbers.\nCreate a 2x2 Matrix and print out the value of each index. Tip: use the eachindex function.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"tip: Solution\nfor i in 2:2:20\n    println(i)\nend\n\na = [1 2; 3 4]\n\nfor i in eachindex(a)\n    println(a[i])\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"using InteractiveUtils","category":"page"},{"location":"3_types/types/#Types","page":"Theory","title":"Types","text":"","category":"section"},{"location":"3_types/types/#Introduction","page":"Theory","title":"Introduction","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"In julia, every variable has a type.  We can use the function typeof (just like in R) to tell us the type of a variable. For example:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"a = 1.0\ntypeof(a)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"b = \"Hello!\"\ntypeof(b)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"c = rand(10)\ntypeof(c)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We see that, for example, the type of double-precision floating point numers is called Float64 in julia.","category":"page"},{"location":"3_types/types/#Abstract-Types","page":"Theory","title":"Abstract Types","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"However, in addition to the types a variable can have, there are so-called \"abstract types\". Abstract types \"bundle\" concrete types together, and form a \"type hierarchy\". Let's have a look:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"typeof(a)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"supertype(Float64)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"subtypes(AbstractFloat)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"The function supertype allows us to inspect the next higher abstract type in the type hierarchy. In this case, this type is called AbstractFloat Caling subtypes on AbstractFloat, we see that Float64 is \"bundled\" together with some other types, for example single precision floating point numbers (Float32). If we would explore this type hierarchy further, we could see something like:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"(Image: Type hiearchy) By Cormullion - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=83858572","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"In julia, we can easily define new abstract types:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"abstract type MySpecialNumber <: Number end","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"defines a new abstract type MySpecialNumber that is a subtype of Number.","category":"page"},{"location":"3_types/types/#Composite-types","page":"Theory","title":"Composite types","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"The most import kind of type we will encounter during this workshop is called a \"composite type\". Composite types are also called \"structs\" and they allow us to create very useful objects.  For example, suppose we are writing a video game for the well-known Pokemon series [1],  we could define some abstract types","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"abstract type Pokemon end\nabstract type Normal <: Pokemon end\nabstract type Flying <: Pokemon end\nabstract type Electric <: Pokemon end","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"and then a composite type","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"struct Pikachu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\nend","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We now have an abstract type Pokemon with subtypes Normal, Fire, Flying and Electric, and a composite type Pikachu which is a subtype of Electric. The composite type Pikachu has the \"fields\" nickname, attack, defense, speed and hp, where we can store the respective values.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We are now able to create our very own Pikachu to fight in our team:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"my_pikachu = Pikachu(\"Pika\", 135, 80, 110, 132)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"which creates a variable my_pikachu of type Pikachu.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We can retrieve the values stored in the fields as","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"my_pikachu.defense","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"compat: Exercise\nCreate a new composite type for a pokemon of your choice of type Flying, create an instance of that pokemon, and retrieve it's nickname.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"tip: Solution\nstruct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)\nmy_crobat.nickname","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"struct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)\nmy_crobat.nickname","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"3_types/types/#Constructors","page":"Theory","title":"Constructors","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Let's talk about how we create new objects. In the example above, we called the type (Pikachu, Crobat) with the values we want to store in the respective fields (Pikachu(\"Pika\", 135, 80, 110, 132)) to create a new instance of that pokemon. However, we may like to have more convenience or safety. For this purpose, we have Constructors: functions that create new objects.","category":"page"},{"location":"3_types/types/#Outer-Constructors","page":"Theory","title":"Outer Constructors","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Outer constructors are mainly for conveniece reasons, and we define them just like functions. For example, we may want to have the option of not giving a new Pokemon a nickname:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"import Random: randstring\nPikachu(attack, defense, speed, hp) = Pikachu(randstring(10), attack, defense, speed, hp)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"So if I want to be lazy and not come up with a nickname, i just sample a random one:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"my_lazy_pikachu = Pikachu(132, 34, 23, 343)","category":"page"},{"location":"3_types/types/#Inner-Constructors","page":"Theory","title":"Inner Constructors","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Inner constructors can be used for enforcing that newly created objects obey certain rules. For example, the way we defined our Pikachu type, there was nothing to tell julia which kind of objects we actually can store in the fields. This allows us to do something like this:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"weird_pikachu = Pikachu(132, 34, 23, -12)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Of course, this is not a valid Pokemon, as the maximum health points can't be negative. To fix this, we use an inner constructor. This is just another function, but defined inside the type definition. Suppose we define another type of Pokemon like this:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"struct Pichu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\n    function Pichu(nickname, attack, defense, speed, hp)\n        if (attack < 0) | (defense < 0) | (speed < 0) | (hp < 0)\n            error(\"Your Pokemon's stats are outside the valide range\")\n        else\n            return new(nickname, attack, defense, speed, hp)\n        end\n    end\nend","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"So we add a function to the type definition that has the same name as the type. This function checks whether the inputs are valid and throws an error if not. If they are valid, it uses the special new function (which is only available inside type definitions) to create a new (hopefully valid) object.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Let's check if it works:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"try  #hide\nweird_pichu = Pichu(\"Pika_2.0\", 132, 34, 23, -12)\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"[1]: Inspired by https://gdalle.github.io/JuliaComputationSolutions/hw1a_solutions.html","category":"page"},{"location":"5_advanced/dual/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Obtaining function derivatives is central in many areas of scientific computing. For example, in numerical optimization, we often need derivatives to find the minimum of a function (maximum likelihood estimation, neural networks, ...). However, deriving derivatives by hand can be quite tedious, especially if you work with frequently changing functions. As numerical differentiation is computationally quite expensive, automatic differentiation libraries have been developed. For example, most Deep Learning libraries employ a form of automatic differentiation called \"backpropagation\". In this example, we will implement one form of automatic differentiation, called \"Forward mode AD\".[1]","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To do so, we heavily rely on the chain rule:  suppose we have functions f mathbbR to mathbbR  g mathbbR to mathbbR. If we compose these functions, we can derive their derivative as ","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"(f(g(x))) = f(g(x)) cdot g(x)","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"With a little bit abuse of notation, instead of defining two functions f and g we will write in the following x mathbbR to mathbbR as a function itself, so the chain rule becomes:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"(f(x)) = f(x) cdot x","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Using the chain rule together with all the other basic differentiation rules you hopefully remember from high school gives:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"beginaligned\n(x + y) = x + y \n(x - y) = x - y \n(x cdot y) = xcdot y + x cdot y \nleft(frac1xright) = frac-xx^2 \nleft(fracxyright) = fracx cdot y - x cdot yy^2 \n(log(x)) = frac1x cdot x \n(sin(x)) = cos(x) cdot x \n(cos(x)) = -sin(x) cdot x \nleft(x^kright) = k cdot x^k-1 cdot x\nendaligned","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"As most functions are compositions of basic functions (of course our list above is not exhaustive, but already sufficient for a lot of things), we can use the chain rule and the differentiation rules for those basic building blocks to \"propagate\" the derivative through more complex functions (just like we propagated the measurement error in the example in Chapter 3).","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nDefine a struct Dual that stores a function value as well as it's derivative as a subtype of Number.","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nstruct Dual <: Number\n    x\n    ∂x\nend","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"struct Dual <: Number\n    x\n    ∂x\nend","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nDefine methods for some of the basic functions described above: +, -, *, /, inv, log, sin, cos, ^. Remember that you have to import them from Base. Don't do all of them (it's tedious), just a few to get the idea.","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>Hint</summary>\n<br>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Hint\nWe could define the multiplication of two dual numbers as:import Base: *\n*(a::Dual, b::Dual) = Dual(a.x*b.x, a.∂x*b.x + a.x*b.∂x)","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: *\n*(a::Dual, b::Dual) = Dual(a.x*b.x, a.∂x*b.x + a.x*b.∂x)","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nimport Base: +, -, *, /, inv, log, sin, cos, ^\n\n+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)\n-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)\n*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)\n^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)\n/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)\ninv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))\nlog(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))\nsin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)\ncos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: +, -, *, /, inv, log, sin, cos, ^\n\n+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)\n-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)\n*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)\n^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)\n/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)\ninv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))\nlog(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))\nsin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)\ncos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\nOf course we also want to be able to have constants in our functions. To make our life a little bit easier, we can treat constant values (aka real numbers) as dual numbers with a derivative of 0. For this purpose, we define how to convert a real number into a dual number, and a \"promotion rule\":","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: convert, promote_rule\n\nconvert(::Type{Dual}, x::Real) = Dual(x, zero(x))\npromote_rule(::Type{Dual}, ::Type{<:Real}) = Dual\nnothing #hide","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We did not cover conversion and promotion in this workshop, so you won't understand this in detail, but the short explanation is this: We write a method for the convert function to tell julia how to \"convert\" an object of type Real to an object of type Dual, so we can now do something like this:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nconvert(Dual, a)","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"that is, a Real number is converted to a dual with a derivative of zero. The promotion rule defines a greater type of two types so that all objects of these types can be converted to it. We now can do something like:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nb = Dual(3.2, 3.47)\npromote(a, b)","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"So given a pair of a Dual and a Real number, promote both numbers to Duals. The beauty of this is that we now can add, multiply, divide, etc. reals and duals without defining any further methods:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nb = Dual(3.2, 3.47)\na*b","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a+b","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a/b","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This is because julia will now \"check\" the defined promotion rules for us, and promote the real number to a dual number, and then use the methods we defined before. If you are interested in details, check the documentation on this topic, but for now it suffices to see that we avoided defining a bunch of methods with this neat trick.","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Now we have implemented a library for automatic differentiation! Let's come up with some random function to take the derivative of:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"f(x) = (x^2*sin(x))/cos(x)^2","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To compute the derivative at point x, simple call the function with Dual(x, 1.0):","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"f(Dual(5.0, 1.0))","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This gives the function value and the derivative of f at point 5. Another function and it's derivative:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"g(x) = log(x)/sin(x^5)\ng(Dual(π, 1.0))","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We can check that we did not messed up by either deriving the derivative by hand or using a numerical approximation:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using FiniteDiff\nFiniteDiff.finite_difference_derivative(g, Float64(π))","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We can also take the partial derivative of functions h mathbbR^n to mathbbR:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"h(x) = sin(x[1]*x[2]^2-x[3])/log(x[1])\nh([4.3, Dual(6.45, 1.0), 3.42])","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"gives the partial derivative w.r.t. x_2 at the point (43 645 342):","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"FiniteDiff.finite_difference_gradient(h, [4.3, 6.45, 3.42])","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To sum up, let's get back to our example from the beginning: linear regression. Recall our setup:","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using Random\nRandom.seed!(1243)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\n\nfunction predict(x, α, β)\n    y = α .+ β*x\n    return y\nend\n\nfunction squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend\nnothing #hide","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nCompute the derivative of the squared error w.r.t. β at the point β = 200, α = 1000.","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>Hint</summary>\n<br>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Hint\nRecall you can compute the squared error assquared_error(y, predict(x, α, β))","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nsquared_error(y, predict(x, 1000, Dual(200.0, 1.0)))","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"squared_error(y, predict(x, 1000, Dual(200.0, 1.0))) #hide","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_advanced/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"[1]: This example is inspired by https://www.wias-berlin.de/people/fuhrmann/AdSciComp-WS2223/week3/","category":"page"},{"location":"0_preparation/introduction/#Preparation","page":"Introduction","title":"Preparation","text":"","category":"section"},{"location":"0_preparation/introduction/","page":"Introduction","title":"Introduction","text":"In this chapter, you will learn how to use julia (installation, setup, loading packages, creating scripts, etc.) If you are an in-person participant in this workshop, you should have received a mail prior to the workshop to complete the Setup instructions. If so, you can skip this part and continue with Working with Julia in VSCode. If you are doing the workshop online or were too lazy to follow the mailed instructions, you should proceed with Setup.","category":"page"},{"location":"3_types/exercise/#Exercise:-Measurements","page":"Exercise","title":"Exercise: Measurements","text":"","category":"section"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"In this exercise, you will define a type which is (hopefully) more closely related to your research than Pokemon. We will continue our example from the first chapter, linear regression. Suppose you collected your data on education, but with some measurement error (people lie about their education, or they are not shure what exactly counts into the number of years, ...). Of course this is not limited to the example of education, but observing data with measurement error is a central concept in most empirical sciences.","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine the composite type Measurement, that is able to store a measurement and the magnitude of error of that measurement. It should be a subtype of AbstractFloat and have an inner constructor that converts the magnitude of measurement to a positive number. Hint: you can use the function abs(...) to take the absolute value of a number.","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nstruct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"struct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine the function ±(value, error) to create a new instance of the Measurement type, and create some measurements.","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\n±(val, err) = Measurement(val, err)\n\nm1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"±(value, error) = Measurement(value, error)\n\nm1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Workshop","category":"page"},{"location":"#What-is-this-Workshop-about?","page":"Home","title":"What is this Workshop about?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hello and welcome to our Julia workshop!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Together, we'll be exploring the amazing world of Julia, a powerful programming language that's taking the world of scientific computing, data science, and research by storm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia is not only known for its ease of use, but also its incredible speed and flexibility. These qualities make it an excellent choice for developers, data scientists, and researchers alike. Let's dive into some of the key reasons why Julia is so awesome:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Superior performance: Julia is fast – very fast. It eliminates the need to use C/C++, Fortran, or other \"slow-productivity\" or \"slow-prototyping\" languages, effectively solving the \"two-language problem.\" This means you can focus on one language for both development and performance optimization.\nUser-friendly syntax: Julia boasts a simple and intuitive syntax that makes it easy for beginners to pick up and for experts to master.\nAdvanced support for Unicode and LaTeX characters: Julia makes it simple to incorporate Unicode and LaTeX characters into your code. Say goodbye to \"alpha\" and \"beta\" and embrace the elegance of α and β.\nRapid prototyping: With Julia, it's easy to add and prototype new algorithms right from the start, allowing you to quickly create efficient, high-performance solutions.","category":"page"},{"location":"#How-to-get-started","page":"Home","title":"How to get started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The core of this workshop consists of 5 chapters (Chapter 0 - Chapter 4) that you can see in the sidebar on the left. You should do them in this order. Chapter 0 is about installing julia and VScode. If you are an in-person participant of this workshop, you should have received a mail prior to the workshop to complete this chapter beforehand, and if you did so, you can skip this chapter. The first Chapter \"Workflow\" explains how to use julia (how to setup your environment, write scripts, load packages, etc.). Chapters 2-4 introduce you to different aspects of the julia language. Each of those chapters has a \"Theory\" part and an \"Exercise\" part. Should you be finished with all chapters and still have time left, you can take a look at the Advanced Materials section.","category":"page"}]
}
