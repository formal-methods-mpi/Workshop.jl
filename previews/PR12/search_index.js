var documenterSearchIndex = {"docs":
[{"location":"Chapter4/dual/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Obtaining function derivatives is central in many areas of scientific computing. For example, in numerical optimization, we often need derivatives to find the minimum of a function (maximum likelihood estimation, neural networks, ...). However, deriving derivatives by hand can be quite tedious, especially if you work with frequently changing functions. As numerical differentiation is computationally quite expensive, automatic differentiation libraries have been developed. For example, most Deep Learning libraries employ a form of automatic differentiation called \"backpropagation\". In this example, we will implement one form of automatic differentiation, called \"Forward mode AD\".","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To do so, we heavily rely on the chain rule:  suppose we have functions f mathbbR to mathbbR  g mathbbR to mathbbR. If we compose these functions, we can derive their derivative as ","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"(f(g(x))) = f(g(x)) cdot g(x)","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"With a little bit abuse of notation, instead of defining two functions f and g we will write in the following x mathbbR to mathbbR as a function itself, so the chain rule becomes:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"(f(x)) = f(x) cdot x","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Using the chain rule together with all the other basic differentiation rules you hopefully remember from high school gives:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"beginaligned\n(x + y) = x + y \n(x - y) = x - y \n(x cdot y) = xcdot y + x cdot y \nleft(frac1xright) = frac-xx^2 \nleft(fracxyright) = fracx cdot y - x cdot yy^2 \n(log(x)) = frac1x cdot x \n(sin(x)) = cos(x) cdot x \n(cos(x)) = -sin(x) cdot x \nleft(x^kright) = k cdot x^k-1 cdot x\nendaligned","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"As most functions are compositions of basic functions (of course our list above is not exhaustive, but already sufficient for a lot of things), we can use the chain rule and the differentiation rules for those basic building blocks to \"propagate\" the derivative through more complex functions (just like we propagated the measurement error in the example in Chapter 3).","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nDefine a struct Dual that stores a function value as well as it's derivative as a subtype of Number.","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nstruct Dual <: Number\n    x\n    ∂x\nend","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"struct Dual <: Number\n    x\n    ∂x\nend","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nDefine methods for some of the basic functions described above: +, -, *, /, inv, log, sin, cos, ^. Remember that you have to import them from Base. Don't do all of them (it's tedious), just a few to get the idea.","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>Hint</summary>\n<br>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Hint\nWe could define the multiplication of two dual numbers as:import Base: *\n*(a::Dual, b::Dual) = Dual(a.x*b.x, a.∂x*b.x + a.x*b.∂x)","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: *\n*(a::Dual, b::Dual) = Dual(a.x*b.x, a.∂x*b.x + a.x*b.∂x)","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nimport Base: +, -, *, /, inv, log, sin, cos, ^\n\n+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)\n-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)\n*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)\n^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)\n/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)\ninv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))\nlog(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))\nsin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)\ncos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: +, -, *, /, inv, log, sin, cos, ^\n\n+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)\n-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)\n*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)\n^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)\n/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)\ninv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))\nlog(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))\nsin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)\ncos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\nOf course we also want to be able to have constants in our functions. To make our life a little bit easier, we can treat constant values (aka real numbers) as dual numbers with a derivative of 0. For this purpose, we define how to convert a real number into a dual number, and a \"promotion rule\":","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: convert, promote_rule\n\nconvert(::Type{Dual}, x::Real) = Dual(x, zero(x))\npromote_rule(::Type{Dual}, ::Type{<:Real}) = Dual\nnothing #hide","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We did not cover conversion and promotion in this workshop, so you won't understand this in detail, but the short explanation is this: We write a method for the convert function to tell julia how to \"convert\" an object of type Real to an object of type Dual, so we can now do something like this:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nconvert(Dual, a)","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"that is, a Real number is converted to a dual with a derivative of zero. The promotion rule defines a greater type of two types so that all objects of these types can be converted to it. We now can do something like:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nb = Dual(3.2, 3.47)\npromote(a, b)","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"So given a pair of a Dual and a Real number, promote both numbers to Duals. The beauty of this is that we now can add, multiply, divide, etc. reals and duals without defining any further methods:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nb = Dual(3.2, 3.47)\na*b","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a+b","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a/b","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This is because julia will now \"check\" the defined promotion rules for us, and promote the real number to a dual number, and then use the methods we defined before. If you are interested in details, check the documentation on this topic, but for now it suffices to see that we avoided defining a bunch of methods with this neat trick.","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Now we have implemented a library for automatic differentiation! Let's come up with some random function to take the derivative of:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"f(x) = (x^2*sin(x))/cos(x)^2","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To compute the derivative at point x, simple call the function with Dual(x, 1.0):","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"f(Dual(5.0, 1.0))","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This gives the function value and the derivative of f at point 5. Another function and it's derivative:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"g(x) = log(x)/sin(x^5)\ng(Dual(π, 1.0))","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We can check that we did not messed up by either deriving the derivative by hand or using a numerical approximation:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using FiniteDiff\nFiniteDiff.finite_difference_derivative(g, Float64(π))","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We can also take the partial derivative of functions h mathbbR^n to mathbbR:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"h(x) = sin(x[1]*x[2]^2-x[3])/log(x[1])\nh([4.3, Dual(6.45, 1.0), 3.42])","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"gives the partial derivative w.r.t. x_2 at the point (43 645 342):","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"FiniteDiff.finite_difference_gradient(h, [4.3, 6.45, 3.42])","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To sum up, let's get back to our example from the beginning: linear regression. Recall our setup:","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using Random\nRandom.seed!(1243)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\n\nfunction predict(x, α, β)\n    y = α .+ β*x\n    return y\nend\n\nfunction squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend\nnothing #hide","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nCompute the derivative of the squared error w.r.t. β at the point β = 200, α = 1000.","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>Hint</summary>\n<br>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Hint\nRecall you can compute the squared error assquared_error(y, predict(x, α, β))","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nsquared_error(y, predict(x, 1000, Dual(200.0, 1.0)))","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"squared_error(y, predict(x, 1000, Dual(200.0, 1.0))) #hide","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"Chapter4/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n!!! danger \"Link\"     Insert a footnote to https://www.wias-berlin.de/people/fuhrmann/AdSciComp-WS2223/week3/     for the dual example","category":"page"},{"location":"Chapter4/intro/#Exercises","page":"Introduction","title":"Exercises","text":"","category":"section"},{"location":"abstract/","page":"-","title":"-","text":"Julia is a high-level dynamic programming language designed for numerical and scientific computing, data analysis, machine learning, and more. Julia's user-friendly interface, resembling popular languages like R, Python, and Matlab, makes it easily accessible for learners. Its focus on performance, however, enables computational speeds that often rival, or even surpass, those of low-level languages such as C or Fortran. Therefore, Julia is an ideal choice for large-scale data analysis and other computationally intensive tasks, as it can be orders of magnitude faster than R or Python. In this workshop, we will introduce you to the basics of Julia and the key features that set it apart from other languages.","category":"page"},{"location":"abstract/","page":"-","title":"-","text":"This workshop is designed for R/Python/Matlab users interested in learning a new programming language or wanting to improve their data analysis and scientific computing skills. No prior experience with Julia is required, but understanding a programming language is recommended.","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"using InteractiveUtils\n\nstruct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend\n\n±(val, err) = Measurement(val, err)","category":"page"},{"location":"Chapter3/exercise/#Exercise","page":"Exercise","title":"Exercise","text":"","category":"section"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"Let's return to our example from the previous chapter, where we defined a new type called Measurement to store a measurement and it's measurement error. We will now define appropriate methods for this type.","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"Let's first take a look at addition: if we add two measurements, a pm b and c pm d, we will get a new measurement","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"(a pm b) + (c pm d) = (a + c) pm (b + d)","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"That is, we add the measured values and the error terms separately.","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine a method for the addition of two measurements. Hint: recall that functions from other modules (like + from Base) have to be imported before you can define a new method for them.","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nimport Base: +\n+(x::Measurement, y::Measurement) = Measurement(x.value + y.value, x.error + y.error)","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"import Base: + #hide\n+(x::Measurement, y::Measurement) = Measurement(x.value + y.value, x.error + y.error) #hide","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"\nWe can now add measurements together:","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"m1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34\n\nm1 + m2","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"Work's like a charm! Subtraction works similarly, so I will define this method for you:","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"    import Base: -\n    -(x::Measurement, y::Measurement) = Measurement(x.value - y.value, x.error + y.error)","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"To make working with our Measurement type a bit more aesthetic, we can even define a new method for Base.show that defines how our type is printed to the REPL:","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"import Base: show\n\nfunction show(io::IO, m::Measurement)\n    value_as_string = string(round(m.value, digits = 2))\n    error_as_string = string(round(m.error, digits = 2))\n    print(io, value_as_string*\" ± \"*error_as_string)\nend\n\nm1","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"But let's get back to more serious business: The next thing we need is to be able to add measurements and real numbers together. We can think of real numbers as measurements without error, so adding a measurement (a pm b) and a real number c should yield","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"(a pm b) + c = (a + c) pm b ","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nAdd methods for the addition of measurements and real numbers. Hint: real numbers are denoted by the type Real.","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\n+(a::Real, b::Measurement) = Measurement(a + b.value, b.error)\n+(a::Measurement, b::Real) = b + a\nm1 + 3.53","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"+(a::Real, b::Measurement) = Measurement(a + b.value, b.error) #hide\n+(a::Measurement, b::Real) = b + a #hide\nm1 + 3.53 #hide","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"\nOkay, to spare you some time, I will define some last methods we need: subtraction and multiplication of real numbers and measurements.  Subtraction works just like addition, and for multiplication we see that","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"c cdot (a pm b) = ca pm cb","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"    -(x::Measurement, y::Real) = Measurement(x.value - y, x.error)\n    -(x::Real, y::Measurement) = Measurement(x - y.value, y.error)\n\n    import Base: *\n    *(x::Measurement, y::Real) = Measurement(x.value*y, abs(x.error*y))\n    *(x::Real, y::Measurement) = y*x","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"Let's see if it all works as planned:","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"    m1 + m2\n    9.34 + m1\n    m2 + 4.52\n    3.5 * m2\n    m2 * 3.5","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"Now for the fun part:  In the exercise to the first chapter, we tried to predict income from years of education with the help of linear regression. Let's simulate some data again:","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"    using Random\n    Random.seed!(1243)\n\n    x = 10 .+ 3*randn(20)\n    β = 300\n    α = 1000\n    y = α .+ β*x + 500*randn(20)\n    nothing #hide","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"This time, let's asume we observed education with some measurement error:","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"    x = Measurement.(x, 2*randn(20))","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"But what happens when we us the education data with measurement error to predict income? Let's find out! We defined our prediction function as","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"    function predict(x, α, β)\n        y = α .+ β*x\n        return y\n    end\n    nothing #hide","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"and if we plug in the values for education with measurement error, we achieve","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"    predict(x, 1000, 300)","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"a prediction of income with the respective measurement error.","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"Hopefully, this serves a a nice illustration of what multiple dispatch together with julias type system is able to achieve. When you wrote the predict function at the beginning of this workshop, you probably had no idea what multiple dispatch even is. But because we are able to define methods for important operations (like *, +), we can use any function or algorithmns that is composed of these operations. This is a very powerful idea that allows for great extensibility and interaperability of different packages. If you don't believe me, imagine somebody has written an R package for linear regression. Now you are in the situation that you have to deal with measurement error. I believe it would be impossible to get the published R package to work with measurement error without rewriting the whole package.","category":"page"},{"location":"Chapter3/exercise/","page":"Exercise","title":"Exercise","text":"Similarly, if you think about our pokemon example from the beginning: If we would like to add more types of pokemon, we just have to define the types (Water, Fire, etc.) and the relevant methods for our functions (effectiveness). Of course, the code we wrote in the pokemon example is rather limited, but this translates seamlessly to complicated packages with more functionality.","category":"page"},{"location":"Chapter2/exercise/#Exercise","page":"Exercise","title":"Exercise","text":"","category":"section"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"In this exercise, you will define a type which is (hopefully) more closely related to your research than Pokemon. We will continue our example from the first chapter, linear regression. Suppose you collected your data on education, but with some measurement error (people lie about their education, or they are not shure what exactly counts into the number of years, ...). Of course this is not limited to the example of education, but observing data with measurement error is a central concept in most empirical sciences.","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine the composite type Measurement, that is able to store a measurement and the magnitude of error of that measurement. It should be a subtype of AbstractFloat and have an inner constructor that converts the magnitude of measurement to a positive number. Hint: you can use the function abs(...) to take the absolute value of a number.","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nstruct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"struct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine the function ±(value, error) to create a new instance of the Measurement type, and create some measurements.","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\n±(val, err) = Measurement(val, err)\n\nm1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"±(value, error) = Measurement(value, error)\n\nm1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34","category":"page"},{"location":"Chapter2/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"using InteractiveUtils\n\nabstract type Pokemon end\nabstract type Normal <: Pokemon end\nabstract type Flying <: Pokemon end\nabstract type Electric <: Pokemon end\n\nstruct Pikachu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nstruct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_pikachu = Pikachu(\"Pika\", 135, 80, 110, 132)\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)","category":"page"},{"location":"Chapter3/dispatch/#Multiple-Dispatch","page":"Methods","title":"Multiple Dispatch","text":"","category":"section"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"We will now approach the central topic of this workshop: multiple dispatch. In julia, functions can behave quite differently, depending on the type of their arguments. For example, let's take a look at the multiplication function *:","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"a = 1.0\nb = 1.0\na * b","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"a = \"Hello \"\nb = \"World\"\na * b","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"a = rand(5, 5)\nb = rand(5, 5)\na * b","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"If we multiply two numbers together, we will get their product, if we multiply two strings together, they are concatenated, and if we multiply two arrays, we get a matrix product. So functions are able to specialise on the type of the input arguments. Every such specialisation we call a method of that function. We can for example take a look at all the methods for *:","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"methods(*)\nnothing # hide","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"# 372 methods for generic function \"*\":\n[1] *(x::T, y::T) where T<:Union{Int128, UInt128} in Base at int.jl:976\n[2] *(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:88\n[3] *(x::T, y::T) where T<:Union{Float16, Float32, Float64} in Base at float.jl:385\n[4] *(s1::Union{AbstractChar, AbstractString}, ss::Union{AbstractChar, AbstractString}...) in Base at strings/basic.jl:260\n[5] *(d::Union{AbstractChar, AbstractString}, x::Missing) in Base at missing.jl:183\n[6] *(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigInt) in Base.GMP at gmp.jl:542\n[7] *(c::Union{Int16, Int32, Int64, Int8}, x::BigInt) in Base.GMP at gmp.jl:544\n[8] *(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigFloat) in Base.MPFR at mpfr.jl:398\n[9] *(c::Union{Int16, Int32, Int64, Int8}, x::BigFloat) in Base.MPFR at mpfr.jl:406\n[10] *(c::Union{Float16, Float32, Float64}, x::BigFloat) in Base.MPFR at mpfr.jl:414\n[11] *(A::StridedMatrix{T}, x::StridedVector{S}) where {T<:Union{Float32, Float64, ComplexF32, ComplexF64}, S<:Real} in LinearAlgebra at /usr/share/julia/stdlib/v1.8/LinearAlgebra/src/matmul.jl:49","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"We see there are quite a number of methods/specialisations available for the * function. To see the particular method that is used for a given combination of arguments, we call","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"@which a*b\nnothing #hide","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"*(A::Union{LinearAlgebra.Adjoint{var\"#s886\", <:StridedMatrix{T} where T}, LinearAlgebra.Transpose{var\"#s886\", <:StridedMatrix{T} where T}, StridedMatrix{var\"#s886\"}} where var\"#s886\"<:Union{Float32, Float64}, B::Union{LinearAlgebra.Adjoint{var\"#s885\", <:StridedMatrix{T} where T}, LinearAlgebra.Transpose{var\"#s885\", <:StridedMatrix{T} where T}, StridedMatrix{var\"#s885\"}} where var\"#s885\"<:Union{Float32, Float64}) in LinearAlgebra at /usr/share/julia/stdlib/v1.8/LinearAlgebra/src/matmul.jl:146","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"and are even able to strg+click on the link to directly take us to the method definition.","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"The crucial part is that methods don't have to be defined together with the function, but that instead we can add methods to existing functions. To add a method to a function from another module, we first import the function:","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"import Base: *","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"and add a new method just like we would define a function","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"function *(a::SomeType, b::AnotherType)\n    ...\nend\n\n*(a::SomeType, b::AnotherType) = ...","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"but we specify on which input-type combination the method should be called (in the above pseudo-code, the method would be called every time we multipy two variables a and b, where a is of type SomeType and b of type AnotherType).","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"Let's practise this a bit. We return to our Pokemon example: suppose we would like to let pokemon fight against each other. As you maybe know, depending on the type of Pokemon (e.g., Normal, Fire, Flight, etc.), the attacks vary in their effectiveness. So let's define a function effectiveness that computes this for us. I will first define the generic fallback defintion, that is used every time there is no special interaction between the types of pokemon fighting:","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"effectiveness(attacker::Pokemon, defender::Pokemon) = 1.0","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"Calling this function on our previously defined Pokemon, we get","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"effectiveness(my_pikachu, my_crobat)","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"However, the rules of Pokemon tell us that we should have the following interactions between the types we defined:","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"↓att/def→ Electric Flying Normal\nElectric 0.5 2 1\nFlying 0.5 1 1\nNormal 1 1 1","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"compat: Exercise\nDefine the missing methods for the effectiveness function according to the table.","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"tip: Solution\neffectiveness(attacker::Electric, defender::Electric) = 0.5\neffectiveness(attacker::Electric, defender::Flying) = 2.0\neffectiveness(attacker::Flying, defender::Electric) = 0.5\n\neffectiveness(my_pikachu, my_crobat)","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"    effectiveness(attacker::Electric, defender::Electric) = 0.5 #hide\n    effectiveness(attacker::Electric, defender::Flying) = 2.0 #hide\n    effectiveness(attacker::Flying, defender::Electric) = 0.5 #hide\n\n    effectiveness(my_pikachu, my_crobat) #hide","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"</details>","category":"page"},{"location":"Chapter3/dispatch/","page":"Methods","title":"Methods","text":"\nWe only have to define 3 methods, because for all other cases, our generic fallback works correctly. We also see, that our function now correctly works for our Pikachu and Crobat, so we succesfully altered the functions behaviour to correctly work on our types.","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"We will finish this chapter with an exercise that makes use of some of the basic syntax elements described before. Our goal is to implement linear regression.  During the course of the workshop, we will come back to this example several times. Let's first have a look at what linear regression is: Suppose you observe the two variables education (in years) and income (per month in dollar), and you want to predict a persons income based on their education. One way to do this is linear regression. Suppose we conducted a study and observed the following data points:","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)\n\nusing Plots\ndefault(legend = false)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\n\nplot(x, y; seriestype=:scatter, xlabel = \"Education\", ylabel = \"Income\")\nsavefig(\"data.png\")","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"(Image: data)","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"On the x-axis, you see the years of education, and on the y-axis you see the monthly income. The task of linear regression is to find a straight line that best describes this relationship:","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"Plots.abline!(β, α)\nsavefig(\"lr.png\")","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"(Image: lr)","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"As you may recal from university, school, or learn just now, a straight line is mathematically described by y = alpha + beta x, where in our case, y corresponds to income and x to years of education.","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nWrite a function predict that takes x, α and β as inputs and returns the predicted value for y.","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction predict(x, α, β)\n    y = α .+ β*x\n    return y\nend","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"function predict(x, α, β)\n    y = α .+ β*x\n    return y\nend","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"Let's simulate some data for the task at hand. First, we load the Random package (a julia package for random number generation) and set a seed (to make our experiments reproducible):","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"Next, we generate some random values for years of education:","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"x = 10 .+ 3*randn(20)","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"This produces a vector of 20 values with 10 years of education as the average, and some normally distributed random variation.","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nUse your previously defined function predict to generate some values for income (y) with α = 1000, β = 300","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\ny = predict(x, 1000, 300)","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"y = predict(x, 1000, 300) #hide","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"\n Since in reality, income dose not perfectly depend on education, but there is some random variation, we add this random variation to y:","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"y += 500*randn(20)","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"And viola! We have some data to work with.","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"In reality of course, we don't know the values for alpha and beta, but we have to estimate them from the data. To do so, we first need some indication of how good a certain combination of values works for our data. Usually, we use the sum of squared errors for this task:","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"sum_i=1^n (haty_i - y_i)^2","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"So we go through all of our n data points (i = 1, ..., n) and for each of those data points we compute the squared distance between the prediction, haty_i, and the value we observed in reality, y_i.","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine a function squared_error that takes a vector of predicted values and a vector of observed values as input and computes the sum of squared errors between them.","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction squared_error(y, ŷ)\n    error = 0.0\n    for i in eachindex(y)\n        error += (y[i] - ŷ[i])^2\n    end\n    return error\nendor, a bit shorter using broadcasting:function squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"function squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nUsing your previously defined predict and squared_error functions to define a function squared_error_regression that takes as input values for α, β, x and y and returns as output the squared error between predictions and observed values. Then, use this function to compute the squared error for the parameter values 1. β = 100, α = 200 and 2. β = 300, α = 1000","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction squared_error_regression(α, β, y, x)\n    return squared_error(y, predict(x, α, β))\nend\n\nsquared_error_regression(200, 100, y, x)\nsquared_error_regression(1000, 300, y, x)","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"function squared_error_regression(α, β, y, x) #hide\n    return squared_error(y, predict(x, α, β)) #hide\nend #hide\n #hide\nsquared_error_regression(200, 100, y, x) #hide","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"squared_error_regression(1000, 300, y, x) #hide","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"Chapter1/exercise/","page":"Exercise","title":"Exercise","text":"\nYou should see that the error corresponding to the true parameters we used to simulate the data is much lower.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Workshop","category":"page"},{"location":"#What-is-this-Workshop-about?","page":"Home","title":"What is this Workshop about?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"import Markdown; Markdown.parse_file(\"../src/abstract.md\")","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"using InteractiveUtils","category":"page"},{"location":"Chapter2/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"Chapter2/types/#Introduction","page":"Types","title":"Introduction","text":"","category":"section"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"In julia, every variable has a type.  We can use the function typeof (just like in R) to tell us the type of a variable. For example:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"a = 1.0\ntypeof(a)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"b = \"Hello!\"\ntypeof(b)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"c = rand(10)\ntypeof(c)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"We see that, for example, the type of double-precision floating point numers is called Float64 in julia.","category":"page"},{"location":"Chapter2/types/#Abstract-Types","page":"Types","title":"Abstract Types","text":"","category":"section"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"However, in addition to the types a variable can have, there are so-called \"abstract types\". Abstract types \"bundle\" concrete types together, and form a \"type hierarchy\". Let's have a look:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"typeof(a)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"supertype(Float64)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"subtypes(AbstractFloat)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"The function supertype allows us to inspect the next higher abstract type in the type hierarchy. In this case, this type is called AbstractFloat Caling subtypes on AbstractFloat, we see that Float64 is \"bundled\" together with some other types, for example single precision floating point numbers (Float32). If we would explore this type hierarchy further, we could see something like:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"danger: Insert picture of type hierarchy\nhttps://en.wikibooks.org/wiki/Introducing_Julia/Types#/media/File:Julia-number-type-hierarchy.svg","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"In julia, we can easily define new abstract types:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"abstract type MySpecialNumber <: Number end","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"defines a new abstract type MySpecialNumber that is a subtype of Number.","category":"page"},{"location":"Chapter2/types/#Composite-types","page":"Types","title":"Composite types","text":"","category":"section"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"The most import kind of type we will encounter during this workshop is called a \"composite type\". Composite types are also called \"structs\" and they allow us to create very useful objects.  For example, suppose we are writing a video game for the well-known Pokemon series,  we could define some abstract types","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"abstract type Pokemon end\nabstract type Normal <: Pokemon end\nabstract type Flying <: Pokemon end\nabstract type Electric <: Pokemon end","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"and then a composite type","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"struct Pikachu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\nend","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"We now have an abstract type Pokemon with subtypes Normal, Fire, Flying and Electric, and a composite type Pikachu which is a subtype of Electric. The composite type Pikachu has the \"fields\" nickname, attack, defense, speed and hp, where we can store the respective values.","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"We are now able to create our very own Pikachu to fight in our team:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"my_pikachu = Pikachu(\"Pika\", 135, 80, 110, 132)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"which creates a variable my_pikachu of type Pikachu.","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"We can retrieve the values stored in the fields as","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"my_pikachu.defense","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"compat: Exercise\nCreate a new composite type for a pokemon of your choice of type Flying, create an instance of that pokemon, and retrieve it's nickname.","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"tip: Solution\nstruct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)\nmy_crobat.nickname","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"struct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)\nmy_crobat.nickname","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"</details>","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"danger: Insert footnote for source of pokemon example\nhttps://gdalle.github.io/JuliaComputationSolutions/hw1a_solutions.html","category":"page"},{"location":"Chapter2/types/#Constructors","page":"Types","title":"Constructors","text":"","category":"section"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"Let's talk about how we create new objects. In the example above, we called the type (Pikachu, Crobat) with the values we want to store in the respective fields (Pikachu(\"Pika\", 135, 80, 110, 132)) to create a new instance of that pokemon. However, we may like to have more convenience or safety. For this purpose, we have Constructors: functions that create new objects.","category":"page"},{"location":"Chapter2/types/#Outer-Constructors","page":"Types","title":"Outer Constructors","text":"","category":"section"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"Outer constructors are mainly for conveniece reasons, and we define them just like functions. For example, we may want to have the option of not giving a new Pokemon a nickname:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"import Random: randstring\nPikachu(attack, defense, speed, hp) = Pikachu(randstring(10), attack, defense, speed, hp)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"So if I want to be lazy and not come up with a nickname, i just sample a random one:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"my_lazy_pikachu = Pikachu(132, 34, 23, 343)","category":"page"},{"location":"Chapter2/types/#Inner-Constructors","page":"Types","title":"Inner Constructors","text":"","category":"section"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"Inner constructors can be used for enforcing that newly created objects obey certain rules. For example, the way we defined our Pikachu type, there was nothing to tell julia which kind of objects we actually can store in the fields. This allows us to do something like this:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"weird_pikachu = Pikachu(132, 34, 23, -12)","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"Of course, this is not a valid Pokemon, as the maximum health points can't be negative. To fix this, we use an inner constructor. This is just another function, but defined inside the type definition. Suppose we define another type of Pokemon like this:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"struct Pichu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\n    function Pichu(nickname, attack, defense, speed, hp)\n        if (attack < 0) | (defense < 0) | (speed < 0) | (hp < 0)\n            error(\"Your Pokemon's stats are outside the valide range\")\n        else\n            return new(nickname, attack, defense, speed, hp)\n        end\n    end\nend","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"So we add a function to the type definition that has the same name as the type. This function checks whether the inputs are valid and throws an error if not. If they are valid, it uses the special new function (which is only available inside type definitions) to create a new (hopefully valid) object.","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"Let's check if it works:","category":"page"},{"location":"Chapter2/types/","page":"Types","title":"Types","text":"try  #hide\nweird_pichu = Pichu(\"Pika_2.0\", 132, 34, 23, -12)\ncatch err; showerror(stderr, err); end  #hide","category":"page"}]
}
