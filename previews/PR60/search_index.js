var documenterSearchIndex = {"docs":
[{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"using InteractiveUtils\n\nabstract type Pokemon end\nabstract type Normal <: Pokemon end\nabstract type Flying <: Pokemon end\nabstract type Electric <: Pokemon end\n\nstruct Pikachu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nstruct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_pikachu = Pikachu(\"Pika\", 135, 80, 110, 132)\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)","category":"page"},{"location":"4_dispatch/dispatch/#Multiple-Dispatch","page":"Theory","title":"Multiple Dispatch","text":"","category":"section"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"We will now approach the central topic of this workshop: multiple dispatch. In julia, functions can behave quite differently, depending on the type of their arguments. For example, let's take a look at the multiplication function *:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"a = 1.0\nb = 1.0\na * b","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"a = \"Hello \"\nb = \"World\"\na * b","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"a = rand(5, 5)\nb = rand(5, 5)\na * b","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"If we multiply two numbers together, we will get their product, if we multiply two strings together, they are concatenated, and if we multiply two arrays, we get a matrix product. So functions are able to specialise on the type of the input arguments. Every such specialisation we call a method of that function. We can for example take a look at all the methods for *:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"methods(*)\nnothing # hide","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"# 372 methods for generic function \"*\":\n[1] *(x::T, y::T) where T<:Union{Int128, UInt128} in Base at int.jl:976\n[2] *(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:88\n[3] *(x::T, y::T) where T<:Union{Float16, Float32, Float64} in Base at float.jl:385\n[4] *(s1::Union{AbstractChar, AbstractString}, ss::Union{AbstractChar, AbstractString}...) in Base at strings/basic.jl:260\n[5] *(d::Union{AbstractChar, AbstractString}, x::Missing) in Base at missing.jl:183\n[6] *(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigInt) in Base.GMP at gmp.jl:542\n[7] *(c::Union{Int16, Int32, Int64, Int8}, x::BigInt) in Base.GMP at gmp.jl:544\n[8] *(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigFloat) in Base.MPFR at mpfr.jl:398\n[9] *(c::Union{Int16, Int32, Int64, Int8}, x::BigFloat) in Base.MPFR at mpfr.jl:406\n[10] *(c::Union{Float16, Float32, Float64}, x::BigFloat) in Base.MPFR at mpfr.jl:414\n[11] *(A::StridedMatrix{T}, x::StridedVector{S}) where {T<:Union{Float32, Float64, ComplexF32, ComplexF64}, S<:Real} in LinearAlgebra at /usr/share/julia/stdlib/v1.8/LinearAlgebra/src/matmul.jl:49","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"We see there are quite a number of methods/specialisations available for the * function. To see the particular method that is used for a given combination of arguments, we call","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"@which a*b\nnothing #hide","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"*(A::Union{LinearAlgebra.Adjoint{var\"#s886\", <:StridedMatrix{T} where T}, LinearAlgebra.Transpose{var\"#s886\", <:StridedMatrix{T} where T}, StridedMatrix{var\"#s886\"}} where var\"#s886\"<:Union{Float32, Float64}, B::Union{LinearAlgebra.Adjoint{var\"#s885\", <:StridedMatrix{T} where T}, LinearAlgebra.Transpose{var\"#s885\", <:StridedMatrix{T} where T}, StridedMatrix{var\"#s885\"}} where var\"#s885\"<:Union{Float32, Float64}) in LinearAlgebra at /usr/share/julia/stdlib/v1.8/LinearAlgebra/src/matmul.jl:146","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"and are even able to strg+click on the link to directly take us to the method definition.","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"The crucial part is that methods don't have to be defined together with the function, but that instead we can add methods to existing functions. To add a method to a function from another module, we first import the function:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"import Base: *","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"and add a new method just like we would define a function","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"function *(a::SomeType, b::AnotherType)\n    ...\nend\n\n*(a::SomeType, b::AnotherType) = ...","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"but we specify on which input-type combination the method should be called (in the above pseudo-code, the method would be called every time we multipy two variables a and b, where a is of type SomeType and b of type AnotherType).","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"Let's practise this a bit. We return to our Pokemon example: suppose we would like to let pokemon fight against each other. As you maybe know, depending on the type of Pokemon (e.g., Normal, Fire, Flight, etc.), the attacks vary in their effectiveness. So let's define a function effectiveness that computes this for us. I will first define the generic fallback defintion, that is used every time there is no special interaction between the types of pokemon fighting:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"effectiveness(attacker::Pokemon, defender::Pokemon) = 1.0","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"Calling this function on our previously defined Pokemon, we get","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"effectiveness(my_pikachu, my_crobat)","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"However, the rules of Pokemon tell us that we should have the following interactions between the types we defined:","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"↓att/def→ Electric Flying Normal\nElectric 0.5 2 1\nFlying 0.5 1 1\nNormal 1 1 1","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"compat: Exercise\nDefine the missing methods for the effectiveness function according to the table.","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"tip: Solution\neffectiveness(attacker::Electric, defender::Electric) = 0.5\neffectiveness(attacker::Electric, defender::Flying) = 2.0\neffectiveness(attacker::Flying, defender::Electric) = 0.5\n\neffectiveness(my_pikachu, my_crobat)","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"    effectiveness(attacker::Electric, defender::Electric) = 0.5 #hide\n    effectiveness(attacker::Electric, defender::Flying) = 2.0 #hide\n    effectiveness(attacker::Flying, defender::Electric) = 0.5 #hide\n\n    effectiveness(my_pikachu, my_crobat) #hide","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"4_dispatch/dispatch/","page":"Theory","title":"Theory","text":"\nWe only have to define 3 methods, because for all other cases, our generic fallback works correctly. We also see, that our function now correctly works for our Pikachu and Crobat, so we succesfully altered the functions behaviour to correctly work on our types.","category":"page"},{"location":"5_additional/extensive-foundations/#Extensive-Foundations","page":"Foundations Revisited","title":"Extensive Foundations","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Welcome back to the workshop! We hope that you had fun following along and that we sparked your interest for this fascinating programming language. Please don't hesitate to ask us any questions or provide feedback on what you liked and didn't like or thought was too easy or too hard. Your input is always welcome and appreciated!","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Next, we will dive into the necessary foundations of the language.","category":"page"},{"location":"5_additional/extensive-foundations/#Variable-assignment","page":"Foundations Revisited","title":"Variable assignment","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"In Julia, variables are used to store data and represent values in your program. Variables have a name and are assigned a value using the assignment operator =. Julia supports both regular (ASCII) variable names and Unicode variable names.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Regular variables are named using alphanumeric characters and underscores, starting with a letter or underscore.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"x = 1\nmy_variable = \"awesome\"\nφ = 1.618","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Unicode variables allow you to use a wider range of characters, including mathematical symbols, Greek letters, and other special characters. To create a Unicode variable, type a backslash followed by the Unicode character name, and then press the Tab key to convert it into the corresponding Unicode symbol. For example, type \\alpha and then press Tab to create the α variable.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"α = 0.05\nβ₁ = 1.2\nΔt = 0.01","category":"page"},{"location":"5_additional/extensive-foundations/#Exercises","page":"Foundations Revisited","title":"Exercises","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Assign the integer value 42 to a variable named theanswerto_life.\nAssign the string \"Julia is fun!\" to a variable named yay.\nAssign the value of 1 + √2 divided by 2 to the variable φ (phi). Remember to use the Unicode character: type \\phi or \\sqrt and press Tab to convert it.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"<details>\n<summary>Show solution</summary>\n<br>","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"tip: Solution\n    # 1. Assign the integer value 42 to a variable named the_answer_to_life.\n    the_answer_to_life = 42\n\n    # 2. Assign the string \"Julia is fun!\" to a variable named yay.\n    yay = \"Julia is fun!\"\n\n    # 3. Assign the value of 1 + √2 divided by 2 to the variable φ (phi).\n    φ = (1 + sqrt(2)) / 2\n\n    # Print out the variables.\n    println(\"The answer to life: \", the_answer_to_life)\n    println(\"Yay: \", yay)\n    println(\"Phi: \", φ)","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"# 1. Assign the integer value 42 to a variable named the_answer_to_life.\nthe_answer_to_life = 42\n\nyay = \"Julia is fun!\"\n\nφ = (1 + sqrt(2)) / 2\n\nprintln(\"The answer to life: \", the_answer_to_life)\nprintln(\"Yay: \", yay)\nprintln(\"Phi: \", φ)","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"</details>","category":"page"},{"location":"5_additional/extensive-foundations/#Functions","page":"Foundations Revisited","title":"Functions","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Excellent! Now that you have a good understanding of variables and the expressive nature of Julia, let's dive into the topic of functions.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"In programming, functions are reusable blocks of code that serve a specific purpose. They play a crucial role in organizing and modularizing code, which in turn enhances its readability and maintainability. For instance, if you've written a chunk of code that performs a specific task or multiple tasks, it would be beneficial to break down the code into individual functions and give each a descriptive name. This approach makes your code more comprehensible and easier to work with. Functions also enable code reuse, minimizing redundancy and simplifying updates, which can save time and effort in the long run.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"The basic syntax for defining a function in Julia is as follows:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"function function_name(arguments)\n    # function body\n    return output\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"The return keyword plays a vital role in specifying the value that a function should output. When no return statement is explicitly provided, the function will return the value of the last expression evaluated in the function body.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"However, it is generally good practice to include a return statement when defining functions using the function keyword, even if the function returns nothing. This approach helps to eliminate ambiguity and ensures that the function's expected output is clear to anyone who reads it.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"For example:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"function add(x, y)\n    return x + y\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"You can also write:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"my_function(arguments) = \"function body\"","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"For example:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"square(x) = x * x","category":"page"},{"location":"5_additional/extensive-foundations/#Exercises-2","page":"Foundations Revisited","title":"Exercises","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Write a function called divide that takes two arguments and returns the result of dividing the first argument by the second.\nWrite a function called cube that takes one argument and returns the cube of the input number.\nWrite a function that checks if a number is even. The function should take one argument and return a Bool.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"<details>\n<summary>Show solution</summary>\n<br>","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"tip: Solution\n# 1. Write a function called divide that takes two arguments and returns the result of dividing the first argument by the second.\nfunction divide(a, b)\n    return a / b\nend\n\n# 2. Write a function called cube that takes one argument and returns the cube of the input number.\ncube(x) = x ^ 3\n\n# 3. Write a function that checks if a number is even. The function should take one argument and return a `Bool`.\nfunction is_even(n)\n    return n % 2 == 0\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"function divide(a, b)\n    return a / b\nend\n\ncube(x) = x ^ 3\n\nfunction is_even(n)\n    return n % 2 == 0\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"</details>","category":"page"},{"location":"5_additional/extensive-foundations/#Vectors","page":"Foundations Revisited","title":"Vectors","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"In Julia, vectors are a fundamental data structure used to store and manipulate collections of values. A vector is a one-dimensional array that can store elements of the same type (e.g., integers, floating-point numbers, or strings). Vectors are useful for representing and processing sequences of data, such as time series, feature vectors, or lists of names.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"To create a vector in Julia, you can use square brackets [] and separate the elements by commas. For example, to create a vector of integers, you would write:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"integer_vector = [1, 2, 3, 4, 5]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"You can access elements of a vector by specifying the index in square brackets. Note that Julia uses 1-based indexing, which means the first element has an index of 1:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"first_element = integer_vector[1]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"You can also assign a new value to an element of a vector by specifying the index in square brackets and using the assignment operator:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"integer_vector[1] = 10","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"However, you cannot assign a new value to an element of a vector if the vector is of a fixed size. For example, if you try to assign a value to index 6 you will get an BoundsError. To add a new element to a vector, you can use the push! function:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"push!(integer_vector, 6)","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Notice the exclamation mark at the end of the function name. This is a convention in Julia that indicates that the function mutates its arguments. This means that the function modifies the original data passed as an argument instead of creating a new copy of the data.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"This will already help you to predict the behavior of the pop! function:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"last_element = pop!(integer_vector)","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Lets create two vectors and see what we can do with them:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"vector1 = [1, 2, 3]\nvector2 = [4, 5, 6]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"When you use standard arithmetic operators (+, -) on vectors, Julia performs element-wise operations.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"added_vectors = vector1 + vector2\nsubtracted_vectors = vector1 - vector2","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Scalar multiplication and division using the standard arithmetic operators (*, /):","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"multiplied_vector = 2 * vector1\ndivided_vector = vector1 / 2","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Vectors can be concatenated with the vcat function or the ; operator:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"concatenated_vector = vcat(vector1, vector2)\nconcatenated_vector = [vector1; vector2]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"However, when we want to multiply two vectors like this:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"multiplied_vectors = vector1 * vector2","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"MethodError: no method matching *(::Vector{Int64}, ::Vector{Int64})","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"We get a MethodError because the * operator is not defined for Vectors.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Now, it depends on what we mean when we want to multiply two vectors. If we want to perform an element-wise multiplication, we need to use the broadcast . operator:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"vector = [1, 2, 3]\nsquared_vector = vector .* 2","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"However, maybe you want to perform the dot product, that is related to matrix multiplication. It is also known as the scalar product, because it always returns a single number, i.e., a scalar. We can do this with the dot function or the ⋅ operator from the LinearAlgebra package:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"using LinearAlgebra\ndot_product = dot(vector1, vector2)\ndot_product = vector1 ⋅ vector2","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Now, at last we can transpose a vector with the transpose function or the ' operator:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"transposed_vector = transpose(vector)\ntransposed_vector = vector'","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Equipped with the transpose operator ', we can now multiply two vectors:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"dot_product = vector1' * vector2","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Arithmetically, this is the same as the dot product!","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Another important concept before we move on is the concept of sequences in Julia.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"In programming, sequences are ordered collections of elements, typically used to represent a series of values or data points. Sequences are essential in various applications, such as iterating through data, generating series of numbers, and organizing data in specific orders.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"In Julia, sequences can be created using ranges and comprehensions. Ranges represent a series of evenly spaced values and can be created using the colon operator : or the range function.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"For example, you can create a range of integers from 1 to 10:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"integer_sequence = 1:10","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"To create a range with a specific step size, you can use the following syntax:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"even_sequence = 2:2:10","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"To convert a sequence to a vector, you can use the collect function:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"integer_vector = collect(integer_sequence)","category":"page"},{"location":"5_additional/extensive-foundations/#Exercises-3","page":"Foundations Revisited","title":"Exercises","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Create a vector of strings and concatenate it with another vector of strings.\nCreate a vector and perform an element-wise square of it.\nCalculate the scalar product of the vector in the way you like.\nRead out an index, set an index, append an element, and pop an element from a vector.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"<details>\n<summary>Show solution</summary>\n<br>","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"tip: Solution\n    # 1. Create a vector of strings and concatenate it with another vector of strings.\n    somestrings = [\"this\", \"is\", \"a\", \"vector\"]\n    somemore = [\"this\", \"is\", \"another\", \"vector\"]\n    vcat(somestrings, somemore)\n\n    # 2. Create a vector and perform an element-wise square of it.\n    avec = [1, 2, 3]\n    avec .^2\n\n    # 3. Calculate the scalar product of the vector in the way you like.\n    42 * avec\n\n    # 4. Read out an index, set an index, append an element, and pop an element from a vector.\n    avec[1]\n\n    avec[2] = 4\n    avec\n\n    push!(avec, 5)\n    pop!(avec)","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"somestrings = [\"this\", \"is\", \"a\", \"vector\"]\nsomemore = [\"this\", \"is\", \"another\", \"vector\"]\nvcat(somestrings, somemore)\n\navec = [1, 2, 3]\navec .^2\n\n42 * avec\n\navec[1]\n\navec[2] = 4\navec\n\npush!(avec, 5)\npop!(avec)","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"</details>","category":"page"},{"location":"5_additional/extensive-foundations/#Matrices","page":"Foundations Revisited","title":"Matrices","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"In Julia, matrices are a fundamental data structure used to store and manipulate two-dimensional arrays of values. A matrix is a rectangular grid of elements, organized into rows and columns, where each element can be accessed by its row and column indices. Matrices are useful for representing and processing structured data, such as images, tables, or linear systems of equations.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"To create a Matrix in Julia, you can use square brackets [] and separate the elements within each row by spaces or commas, and separate the rows by semicolons ;. For example, to create a square matrix of integers, you would write:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"square_matrix = [1 2 3; 4 5 6; 7 8 9]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"You can access elements of a matrix by specifying the row and column indices in square brackets, separated by a comma. Note that Julia uses 1-based indexing, which means the first row and column have an index of 1:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"upper_left_element = square_matrix[1, 1]\nlower_right_element = square_matrix[3, 3]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"As you can see, many things are the same as with vectors, which is not surprising, since vectors are just 1-dimensional matrices.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Lets define a 2x3 Matrix ...","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"non_square_matrix = [1 2 3; 4 5 6]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"... and transpose it with the transpose function or the quote ' operator:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"transposed_matrix = transpose(non_square_matrix)\ntransposed_matrix = non_square_matrix'","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Let's create two matrices and see what we can do with them:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"matrix1 = [1 2; 3 4]\nmatrix2 = [5 6; 7 8]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"We already know from the chapter about Vectors that we can use the vcat function or semicolon ; for vertical concatenation:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"vertically_concatenated_matrix = vcat(matrix1, matrix2)  # Returns [1 2; 3 4; 5 6; 7 8]\nvertically_concatenated_matrix = [matrix1; matrix2]      # Also returns [1 2; 3 4; 5 6; 7 8]","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Concatenate two matrices horizontally using the hcat function or space  :","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"concatenated_matrix = hcat(matrix1, matrix2)\nconcatenated_matrix = [matrix1 matrix2]","category":"page"},{"location":"5_additional/extensive-foundations/#Exercises-4","page":"Foundations Revisited","title":"Exercises","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Define two square matrices and add and subtract them with each other.\nPerform an element-wise multiplication of two matrices and then a matrix multiplication.\nWrite a vector with spaces, e.g.,: [1 2 3]. Is that really a vector?\nFind out what else you can do with matrices by writing methodswith(Matrix) in the REPL.\nLook into the documentation of ?something you are interested in, then try it out in the REPL.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"<details>\n<summary>Show solution</summary>\n<br>","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"tip: Solution\n    # 1. Define two square matrices and add and subtract them with each other.\n    matrixA = [1 2; 3 4]\n    matrixB = [5 6; 7 8]\n    matrixAddition = matrixA + matrixB\n    matrixSubtraction = matrixA - matrixB\n    println(\"Matrix Addition: \")\n    println(matrixAddition)\n    println(\"Matrix Subtraction: \")\n    println(matrixSubtraction)\n\n    # 2. Perform an element-wise multiplication of two matrices and then a matrix multiplication.\n    elementWiseMultiplication = matrixA .* matrixB\n    matrixMultiplication = matrixA * matrixB\n    println(\"Element-wise multiplication: \")\n    println(elementWiseMultiplication)\n    println(\"Matrix multiplication: \")\n    println(matrixMultiplication)\n\n    # 3. Write a vector with spaces, e.g.,: [1 2 3]. Is that really a vector?\n    vec = [1 2 3]\n    println(\"1D Matrix: \")\n    println(vec)\n    vec = [1, 2, 3]\n    println(\"Vector: \")\n    println(vec)\n\n    # Note: For the 4th and 5th task, you'll have to use Julia's REPL (Read-Eval-Print Loop).\n    # It's not possible to run these commands here.\n\n    # 4. methodswith(Matrix) # Uncomment this line in the Julia REPL to get the methods for Matrix.\n\n    # 5. ?rand # Uncomment this line in the Julia REPL to get the documentation for the rand function.\n","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"matrixA = [1 2; 3 4]\nmatrixB = [5 6; 7 8]\nmatrixAddition = matrixA + matrixB\nmatrixSubtraction = matrixA - matrixB\nprintln(\"Matrix Addition: \")\nprintln(matrixAddition)\nprintln(\"Matrix Subtraction: \")\nprintln(matrixSubtraction)\n\nelementWiseMultiplication = matrixA .* matrixB\nmatrixMultiplication = matrixA * matrixB\nprintln(\"Element-wise multiplication: \")\nprintln(elementWiseMultiplication)\nprintln(\"Matrix multiplication: \")\nprintln(matrixMultiplication)\n\nvec = [1 2 3]\nprintln(\"1D Matrix: \")\nprintln(vec)\nvec = [1, 2, 3]\nprintln(\"Vector: \")\nprintln(vec)","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"</details>","category":"page"},{"location":"5_additional/extensive-foundations/#Arrays","page":"Foundations Revisited","title":"Arrays","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Without going too much into the details, it is important to know about the concept of arrays in Julia.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Arrays are a fundamental data structure in Julia that can be used to represent and manipulate multi-dimensional collections of values. Vectors and matrices are special cases of arrays, where vectors are one-dimensional arrays and matrices are two-dimensional arrays. Arrays can have more than two dimensions, allowing you to work with higher-dimensional data structures in a consistent and efficient way.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"The concept of arrays generalizes vectors and matrices by extending their properties and operations to multiple dimensions. This means that most of the functions and operations you have learned for vectors and matrices can be applied to arrays with higher dimensions as well.","category":"page"},{"location":"5_additional/extensive-foundations/#Control-Flow","page":"Foundations Revisited","title":"Control Flow","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Control flow refers to the order in which statements or instructions are executed in a program. It is an essential concept in programming, as it allows you to create more dynamic and flexible code. Two fundamental control flow structures are loops and conditional statements. Loops allow you to repeat a block of code multiple times, while conditional statements enable you to execute a block of code only if certain conditions are met.","category":"page"},{"location":"5_additional/extensive-foundations/#For-Loops","page":"Foundations Revisited","title":"For Loops","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"For loops in Julia are used to iterate over a range of values or the elements of a collection, such as an array or a tuple. The syntax for a for loop is as follows:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"for variable in collection\n    # Code to be executed for each value in the collection\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"For example:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"for i in 1:5\n    println(i^2)\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"If statements in Julia are used to execute a block of code only if a specific condition is met. The syntax for an if statement is as follows:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"if condition\n    # Code to be executed if the condition is true\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"You can also use elseif and else to test multiple conditions:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"if condition1\n    # Code to be executed if condition1 is true\nelseif condition2\n    # Code to be executed if condition1 is false and condition2 is true\nelse\n    # Code to be executed if both condition1 and condition2 are false\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"For example, to check if a number is positive, negative, or zero:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"number = -3\n\nif number > 0\n    println(\"The number is positive\")\nelseif number < 0\n    println(\"The number is negative\")\nelse\n    println(\"The number is zero\")\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Let's remember what we learned about functions!","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"function classify_sign(number)\n    if number > 0\n        println(\"The number is positive\")\n    elseif number < 0\n        println(\"The number is negative\")\n    else\n        println(\"The number is zero\")\n    end\nend","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Now we can use the function to classify any number we want:","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"classify_sign(3)\nclassify_sign(-3)\nclassify_sign(0)","category":"page"},{"location":"5_additional/extensive-foundations/#Exercises-5","page":"Foundations Revisited","title":"Exercises","text":"","category":"section"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"Write a for loop that prints the first 10 even numbers.\nCreate a 2x2 Matrix and print out the value of each index. Tip: use the length function.\nWrite a nested loop with i and j and add each index if both are equal and prints the result.\nCreate a 3-dimension and 4-dimensional array and call size and length on them.","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"<details>\n<summary>Show solution</summary>\n<br>","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"tip: Solution\n    # 1. Write a for loop that prints the first 10 even numbers.\n    println(\"First 10 even numbers: \")\n    for i in 1:10\n        println(2 * i)\n    end\n\n    # 2. Create a 2x2 Matrix and print out the value of each index. Tip: use the `length` function.\n    matrix = [1 2; 3 4]\n    println(\"Values in the 2x2 matrix: \")\n    for i in 1:length(matrix)\n        println(matrix[i])\n    end\n\n    # 3. Write a nested loop with `i` and `j` and add each index if both are equal and prints the result.\n    println(\"Results from nested loop: \")\n    for i in 1:5\n        for j in 1:5\n            if i == j\n                println(i + j)\n            end\n        end\n    end\n\n    # 4. Create a 3-dimension and 4-dimensional array and call `size` and `length` on them.\n    threeDArray = rand(3, 3, 3)\n    fourDArray = rand(3, 3, 3, 3)\n    println(\"Size and length of the 3D array: \")\n    println(size(threeDArray))\n    println(length(threeDArray))\n    println(\"Size and length of the 4D array: \")\n    println(size(fourDArray))\n    println(length(fourDArray))","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"println(\"First 10 even numbers: \")\nfor i in 1:10\n    println(2 * i)\nend\n\nmatrix = [1 2; 3 4]\nprintln(\"Values in the 2x2 matrix: \")\nfor i in eachindex(matrix)\n    println(matrix[i])\nend\n\nprintln(\"Results from nested loop: \")\nfor i in 1:5\n    for j in 1:5\n        if i == j\n            println(i + j)\n        end\n    end\nend\n\nthreeDArray = rand(3, 3, 3)\nfourDArray = rand(3, 3, 3, 3)\nprintln(\"Size and length of the 3D array: \")\nprintln(size(threeDArray))\nprintln(length(threeDArray))\nprintln(\"Size and length of the 4D array: \")\nprintln(size(fourDArray))\nprintln(length(fourDArray))","category":"page"},{"location":"5_additional/extensive-foundations/","page":"Foundations Revisited","title":"Foundations Revisited","text":"</details>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"using InteractiveUtils\n\nstruct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend\n\n±(val, err) = Measurement(val, err)","category":"page"},{"location":"4_dispatch/exercise/#Exercise:-Combining-Linear-Regression-and-Measurements","page":"Exercise","title":"Exercise: Combining Linear Regression and Measurements","text":"","category":"section"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Let's return to our example from the previous chapter, where we defined a new type called Measurement to store a measurement and it's measurement error. We will now define appropriate methods for this type.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Let's first take a look at addition: if we add two measurements, a pm b and c pm d, we will get a new measurement","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"(a pm b) + (c pm d) = (a + c) pm (b + d)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"That is, we add the measured values and the error terms separately.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine a method for the addition of two measurements. Hint: recall that functions from other modules (like + from Base) have to be imported before you can define a new method for them.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nimport Base: +\n+(x::Measurement, y::Measurement) = Measurement(x.value + y.value, x.error + y.error)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"import Base: + #hide\n+(x::Measurement, y::Measurement) = Measurement(x.value + y.value, x.error + y.error) #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"\nWe can now add measurements together:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"m1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34\n\nm1 + m2","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Work's like a charm! Subtraction works similarly, so I will define this method for you:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"import Base: -\n-(x::Measurement, y::Measurement) = Measurement(x.value - y.value, x.error + y.error)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"To make working with our Measurement type a bit more aesthetic, we can even define a new method for Base.show that defines how our type is printed to the REPL:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"import Base: show\n\nfunction show(io::IO, m::Measurement)\n    value_as_string = string(round(m.value, digits = 2))\n    error_as_string = string(round(m.error, digits = 2))\n    print(io, value_as_string*\" ± \"*error_as_string)\nend\n\nm1","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"But let's get back to more serious business: The next thing we need is to be able to add measurements and real numbers together. We can think of real numbers as measurements without error, so adding a measurement (a pm b) and a real number c should yield","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"(a pm b) + c = (a + c) pm b ","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nAdd methods for the addition of measurements and real numbers. Hint: real numbers are denoted by the type Real.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\n+(a::Real, b::Measurement) = Measurement(a + b.value, b.error)\n+(a::Measurement, b::Real) = b + a\nm1 + 3.53","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"+(a::Real, b::Measurement) = Measurement(a + b.value, b.error) #hide\n+(a::Measurement, b::Real) = b + a #hide\nm1 + 3.53 #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"\nOkay, to spare you some time, I will define some last methods we need: subtraction and multiplication of real numbers and measurements.  Subtraction works just like addition, and for multiplication we see that","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"c cdot (a pm b) = ca pm cb","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"-(x::Measurement, y::Real) = Measurement(x.value - y, x.error)\n-(x::Real, y::Measurement) = Measurement(x - y.value, y.error)\n\nimport Base: *\n*(x::Measurement, y::Real) = Measurement(x.value*y, abs(x.error*y))\n*(x::Real, y::Measurement) = y*x","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Let's see if it all works as planned:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"m1 + m2\n9.34 + m1\nm2 + 4.52\n3.5 * m2\nm2 * 3.5","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Now for the fun part:  In the exercise to the first chapter, we tried to predict income from years of education with the help of linear regression. Let's simulate some data again:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\nnothing #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"This time, let's asume we observed education with some measurement error:","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"x = Measurement.(x, 2*randn(20))","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"But what happens when we us the education data with measurement error to predict income? Let's find out! We defined our prediction function as","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"function predict(x, α, β)\n    y = α .+ β*x\n    return y\nend\nnothing #hide","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"and if we plug in the values for education with measurement error, we achieve","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"predict(x, 1000, 300)","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"a prediction of income with the respective measurement error.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Hopefully, this serves a a nice illustration of what multiple dispatch together with julias type system is able to achieve. When you wrote the predict function at the beginning of this workshop, you probably had no idea what multiple dispatch even is. But because we are able to define methods for important operations (like *, +), we can use any function or algorithmn that is composed of these operations. This is a very powerful idea that allows for great extensibility and interaperability of different packages. If you don't believe me, imagine somebody has written an R package for linear regression. Now you are in the situation that you have to deal with measurement error. I believe it would be impossible to get the published R package to work with measurement error without rewriting the whole package.","category":"page"},{"location":"4_dispatch/exercise/","page":"Exercise","title":"Exercise","text":"Similarly, if you think about our pokemon example from the beginning: If we would like to add more types of pokemon, we just have to define the types (Water, Fire, etc.) and the relevant methods for our functions (effectiveness). Of course, the code we wrote in the pokemon example is rather limited, but this translates seamlessly to complicated packages with more functionality.","category":"page"},{"location":"letsgo/#Welcome!","page":"Welcome!","title":"Welcome!","text":"","category":"section"},{"location":"letsgo/","page":"Welcome!","title":"Welcome!","text":"Hello and welcome to our Julia workshop! We are excited that you go on this journey with us.","category":"page"},{"location":"letsgo/","page":"Welcome!","title":"Welcome!","text":"The workshop is self-paced, therefore you can spend as much or as little time on each chapter/exercise as you want. Make sure manage your time a little bit and do not dwell on things that are already clear to you. You can at anytime raise your (virtual) hand and ask questions.","category":"page"},{"location":"letsgo/#Overview","page":"Welcome!","title":"Overview","text":"","category":"section"},{"location":"letsgo/","page":"Welcome!","title":"Welcome!","text":"In the menu to the left, you should see the Chapters 0-4:","category":"page"},{"location":"letsgo/","page":"Welcome!","title":"Welcome!","text":"import Markdown; Markdown.parse_file(\"../src/reuse/chapter-overview.md\")","category":"page"},{"location":"letsgo/#Let's-go","page":"Welcome!","title":"Let's go","text":"","category":"section"},{"location":"letsgo/","page":"Welcome!","title":"Welcome!","text":"Working with Julia in VSCode","category":"page"},{"location":"2_syntax/exercise/#Exercise:-Linear-Regression","page":"Exercise","title":"Exercise: Linear Regression","text":"","category":"section"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"We will finish this chapter with an exercise that makes use of some of the basic syntax elements described before. Our goal is to implement linear regression. During the course of the workshop, we will come back to this example several times. Let's first have a look at what linear regression is: Suppose you observe the two variables education (in years) and income (per month in dollar), and you want to predict a persons income based on their education. One way to do this is linear regression. Suppose we conducted a study and observed the following data points:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)\n\nusing Plots\ndefault(legend = false)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\n\nplot(x, y; seriestype=:scatter, xlabel = \"Education\", ylabel = \"Income\")\nsavefig(\"data.png\")","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"(Image: data)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"On the x-axis, you see the years of education, and on the y-axis you see the monthly income. The task of linear regression is to find a straight line that best describes this relationship:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"Plots.abline!(β, α)\nsavefig(\"lr.png\")","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"(Image: lr)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"As you may recal from university, school, or learn just now, a straight line is mathematically described by y = alpha + beta x, where in our case, y corresponds to income and x to years of education.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nWrite a function predict that takes x, α and β as inputs and returns the predicted value for y.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction predict(x, α, β)\n    y = α .+ β*x\n    return y\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"function predict(x, α, β)\n    y = α .+ β*x\n    return y\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"Let's simulate some data for the task at hand. First, we load the Random package (a julia package for random number generation) and set a seed (to make our experiments reproducible):","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"using Random\nRandom.seed!(1243)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"Next, we generate some random values for years of education:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"x = 10 .+ 3*randn(20)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"This produces a vector of 20 values with 10 years of education as the average, and some normally distributed random variation.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nUse your previously defined function predict to generate some values for income (y) with α = 1000, β = 300","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\ny = predict(x, 1000, 300)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"y = predict(x, 1000, 300) #hide","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n Since in reality, income does not perfectly depend on education, but there is some random variation, we add this random variation to y:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"y += 500*randn(20)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"And viola! We have some data to work with.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"In reality of course, we don't know the values for alpha and beta, but we have to estimate them from the data. To do so, we first need some indication of how good a certain combination of values works for our data. Usually, we use the sum of squared errors for this task:","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"sum_i=1^n (haty_i - y_i)^2","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"So we go through all of our n data points (i = 1, ..., n) and for each of those data points we compute the squared distance between the prediction, haty_i, and the value we observed in reality, y_i.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine a function squared_error that takes a vector of predicted values and a vector of observed values as input and computes the sum of squared errors between them.","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction squared_error(y, ŷ)\n    error = 0.0\n    for i in eachindex(y)\n        error += (y[i] - ŷ[i])^2\n    end\n    return error\nendor, a bit shorter using broadcasting:function squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"function squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nUsing your previously defined predict and squared_error functions to define a function squared_error_regression that takes as input values for α, β, x and y and returns as output the squared error between predictions and observed values. Then, use this function to compute the squared error for the parameter values 1. β = 100, α = 200 and 2. β = 300, α = 1000","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nfunction squared_error_regression(α, β, y, x)\n    return squared_error(y, predict(x, α, β))\nend\n\nsquared_error_regression(200, 100, y, x)\nsquared_error_regression(1000, 300, y, x)","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"function squared_error_regression(α, β, y, x) #hide\n    return squared_error(y, predict(x, α, β)) #hide\nend #hide\n #hide\nsquared_error_regression(200, 100, y, x) #hide","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"squared_error_regression(1000, 300, y, x) #hide","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"2_syntax/exercise/","page":"Exercise","title":"Exercise","text":"\n You should see that the error corresponding to the true parameters we used to simulate the data is much lower.","category":"page"},{"location":"5_additional/syntax/#Syntax-Review","page":"Syntax Review","title":"Syntax Review","text":"","category":"section"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"Ah, excellent! You're all set up and ready to explore. Let's get started!","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"We will be working through a few examples to get you started. Because the Julia documentation already is very detailed about the language, we'll be focusing on the most important parts of the language. If you want to get a more complete overview of the language language or you have specific questions, we recommend you to read the Julia documentation. While doing the workshop you should ask us of course!","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"First we need to get acuainted with julias number types, variables, logical operators and functions. Because we thing it is boring if we just list all the operators and functions, we will use them in some examples. So let's get started","category":"page"},{"location":"5_additional/syntax/#Assignment-function-definition-vectors-matrices-indices-control-flow-(for-/-if)-broadcasting","page":"Syntax Review","title":"Assignment + function definition + vectors + matrices + indices + control flow (for / if) + broadcasting","text":"","category":"section"},{"location":"5_additional/syntax/#broadcast-square-over-array","page":"Syntax Review","title":"broadcast square over array","text":"","category":"section"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"x = 1","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"#unicode","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"#hello world","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"3 == 3.0     # true (integer and float comparison)\n3 != 3.0     # false (integer and float comparison)\n\"hello\" == \"hello\"   # true (string comparison)\n\"hello\" != \"world\"   # true (string comparison)\n\n4//5 < 0.75  # false (rational and float comparison)\n4//5 > 0.75  # true  (rational and float comparison)\n\"apple\" < \"banana\"   # true (string comparison based on lexicographic order)\n\"apple\" > \"banana\"   # false (string comparison based on lexicographic order)\n\n1//2 <= 0.5  # true (rational and float comparison)\n1//2 >= 0.5  # true (rational and float comparison)\n\"hello\" <= \"world\"   # true (string comparison based on lexicographic order)\n\"hello\" >= \"world\"   # false (string comparison based on lexicographic order)\n\n!true  # false (not operator)\n\n(3 == 3.0) && (\"apple\" < \"banana\")  # true (and operator)\n(3 != 3.0) || (4//5 < 0.75)         # false (or operator)\n\n(1//2 <= 0.5) && (\"hello\" >= \"world\")   # false (and operator with mixed types)\n(1//2 >= 0.5) || (\"hello\" <= \"world\")   # true (or operator with mixed types)\n\n!(\"hello\" == \"world\")               # true (not operator with string comparison)","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"==: Equality operator, checks whether two values are equal.\n!= or ≠: Inequality operator, checks whether two values are not equal.\n<: Less than operator, checks whether the left value is less than the right value.\n>: Greater than operator, checks whether the left value is greater than the right value.\n<= or ≤: Less than or equal to operator, checks whether the left value is less than or equal to the right value.\n>= or ≥: Greater than or equal to operator, checks whether the left value is greater than or equal to the right value.\n!: NOT operator, inverts the value of a boolean.\n&&: AND operator, returns true if both values are true.\n||: OR operator, returns true if at least one of the values is true.","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"You might be thinking, but how do I write that ≠ sign in Julia. \\ne<tab> will give you the ≠ sign. You can also use \\le<tab> for ≤ and \\ge<tab> for ≥.","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"You can use these also for variables by writing \\delta<tab> for δ and \\alpha<tab> for α.","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"δ = 2 - 1.3\nα = 3 * 4","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"You can already see that Julia easily handles different types of numbers. You can check their type with the typeof function.","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"typeof(δ)  # Float64\ntypeof(α)  # Int64","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"Creating functions in Julia is a straightforward process. To define a function, you can use the function keyword, followed by the function name, and enclose the function body in a block using the end keyword. By default, functions in Julia return the value of the last expression, which eliminates the need for an explicit return statement. However, it is a recommended practice to include a return statement to make it easier to understand what the function is returning. To evaluate an expression and include its result in a string, you can use the $ symbol within the string for interpolation.","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"function greet(name)\n    greeting = \"Hello, $(name)!\"\n    return greeting\nend","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"greet(\"Julia Explorer\")  # Output: Hello, Julia Explorer!","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"If we have a short function like this, we can also define it in a single line:","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"greet(name) = \"Hello, $(name)!\"","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"To better understand interpolation, let's consider another example. If we're interpolating a single variable, we don't need to use braces. But why did we do that in the previous example? Including braces helps Julia identify and resolve the variable more easily. Without braces, Julia would've produced an error stating that it can't find the variable name! and we would have had to add an additional whitespace. Additionally, braces are necessary when interpolating more complicated expressions, as in the next example:","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"x = 1`\ny = 2//3\nstring_output = \"The sum of $x and $y is $(x + y).\"","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"Awesome! Now lets look at control flow statements, such as if, for, while, and break and combine them with what we've learned so far:","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"function check_x(x)\n    if x < 5\n        println(\"x is less than 5\")\n    elseif x > 5\n        println(\"x is greater than 5\")\n    else\n        println(\"x is equal to 5\")\n    end\nend","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"check_x(10) # Output: x is greater than 5\ncheck_x(4//7)","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"naming, snakecase vs camelcase","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"You can see that Julia easily works with different types of numbers, even though you dont have to worry about them.","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"However, Julia will throw an error if we pass a complex number:","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"check_x(4+3im)","category":"page"},{"location":"5_additional/syntax/#explain-sequences","page":"Syntax Review","title":"explain sequences","text":"","category":"section"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"function print_numbers(start, stop)\n    for i in start:stop\n        println(i)\n    end\nend","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"function print_numbers(x)\n    while x < 10\n        println(x)\n        x += 1\n    end\nend","category":"page"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"function print_numbers()\n    for i in 1:10\n        if i == 5\n            break\n        end\n        println(i)\n    end\nend","category":"page"},{"location":"5_additional/syntax/#Resources","page":"Syntax Review","title":"Resources","text":"","category":"section"},{"location":"5_additional/syntax/","page":"Syntax Review","title":"Syntax Review","text":"Julia Docs - Integers and Floating-Point Numbers Julia Docs - Rational and Complex Numbers Julia Docs - Mathematical Operations Julia Docs - Strings","category":"page"},{"location":"1_workflow/usage/#Working-with-Julia-in-VSCode","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"We will now learn how to use Julia in Visual Studio Code (VSCode) through some examples, so let's tackle everything together. If you feel slightly overwhelmed at first, don't worry — that's perfectly natural. It takes time to become familiar with a tool like VSCode.","category":"page"},{"location":"1_workflow/usage/#Create-a-folder-for-the-workshop","page":"Working with Julia in VSCode","title":"Create a folder for the workshop","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"First, we'll want to create a dedicated folder for our workshop. VSCode isn't particularly friendly when it comes to navigating files/folders. So don't try to use VSCode for that. Instead, we will use our operating system for that, i.e., just use your Explorer/Finder and create a folder in a location that makes sense to you. Once you've done that, you can open the folder in VSCode by navigating to the Menu Bar and selecting File > Open Folder and then selecting the folder you just created.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Next, let's create a new file within our workshop folder. To do this, right-click within the folder's file explorer in VSCode, and select \"New File.\" Name this file introduction.jl and then open it by double-clicking on the file name. In this file, write the following code:","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"println(\"Hello, Julia!\")","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Now, we'll execute this code using the Command Palette. To open the Command Palette, press Ctrl+Shift+P (Windows/Linux) or Cmd+Shift+P (Mac). In the Command Palette search bar, type \"execute,\" and then look for the option \"Julia: Execute Code in REPL and Move\" Take note what the displayed shortcut for executing code in the REPL is - you can use this shortcut in the the future to execute a line of code from your script. Leave the command palette by clicking on the background, click on the line of code you just worte, and hit the shortcut to execute it. The code you've written should be executed, displaying \"Hello, Julia!\" in the REPL window that opens up at the bottom of VSCode.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Great! You've just executed your first line of Julia in VSCode!","category":"page"},{"location":"1_workflow/usage/#The-Julia-REPL","page":"Working with Julia in VSCode","title":"The Julia REPL","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"The Julia REPL (Read-Eval-Print Loop) is an interactive and modern command-line interface for the Julia programming language. It allows you to enter Julia expressions, execute them, and see the results immediately. This makes the REPL a great place to experiment with Julia, test ideas, get help, and much more.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"The REPL has several differend modes:","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"The normal Julia mode\nHelp mode\nPackage mode\nShell mode","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"We will cover each of these modes, except the shell mode, in the following sections.","category":"page"},{"location":"1_workflow/usage/#Julia-mode","page":"Working with Julia in VSCode","title":"Julia mode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"This is the default mode when you start the REPL. Here, you can enter and execute Julia expressions. To return to Julia mode from any other mode, press Backspace.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"compat: Exercise\nAdd two numbers in the REPL.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"tip: Solution\njulia> 3+4\n7","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"</details>","category":"page"},{"location":"1_workflow/usage/#Help-mode","page":"Working with Julia in VSCode","title":"Help mode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"To access Help mode, press ?. In this mode, you can search for documentation and information about various Julia functions, types, and keywords.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"compat: Exercise\nTo find information on the println function, enter Help mode by pressing ?. Once in Help mode, simply type println and press Enter to retrieve the relevant documentation.\nLook for an alternative print function by entering \"print\" (with quotation marks) in the search field. Julia will subsequently provide a list of definitions where the string \"print\" appears in the associated documentation.","category":"page"},{"location":"1_workflow/usage/#Package-mode","page":"Working with Julia in VSCode","title":"Package mode","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Access Package mode by pressing ]. This mode is dedicated to managing Julia packages using the built-in package manager, Pkg. In Package mode, you can add, update, remove, and list installed packages, among other tasks.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"compat: Exercise\nEnter Package mode by pressing ].Install the Example package: add Example.\nList the installed packages: status.\nRemove the Example package: rm Example.\nDiscover what else you can type in Package mode by entering help or ?.","category":"page"},{"location":"1_workflow/usage/#Restarting-the-REPL","page":"Working with Julia in VSCode","title":"Restarting the REPL","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"We've already talked about the REPL and its various modes. Now, let's learn how to restart it.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Restarting the REPL in Julia is a step you'll need to take occasionally, especially when you've made certain changes to your code (you will learn when this is required later). When you create or alter code elements, they're stored in the current Julia session. But sometimes, you'll need to restart the session so that the REPL can properly understand these changes.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Don't worry about the specifics yet. For now, just remember that restarting the REPL is part of the process and is something we'll be doing throughout this course.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Restarting the REPL in VSCode is easy. Just press Alt + J and then Alt + R. If you wait too long between pressing these keys, VSCode may not recognize it as a single command, so try to do it quickly.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Restarting the REPL gives you a clean slate. It removes all variables you previously defined or packages you loaded.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"If you forget how to restart the REPL, or want to find other shortcuts, you can always open the Command Palette and search for \"restart\".","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Remember, each time you restart the REPL, any variables or functions you've defined will be erased. So it's important to keep your code in a script file. This way, after a restart, you can just run your script again to get back where you were. It's good practice to keep this file tidy so it runs smoothly from start to finish. By the end of the workshop, we aim to have one script file that can be run in a single go.","category":"page"},{"location":"1_workflow/usage/#Making-Use-of-the-Tab-Key-for-Autocompletion-in-REPL","page":"Working with Julia in VSCode","title":"Making Use of the Tab Key for Autocompletion in REPL","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"In the REPL (Read-Eval-Print-Loop) environment, the Tab key has a helpful role beyond its usual function. This key assists in your programming tasks by providing autocompletion, suggesting commands based on what you've started to type and what's applicable in your current scope.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Let's say you've started typing 'pr' – hitting the Tab key after this triggers REPL to present all commands that start with 'pr'. Want to peek into the contents of a package? Simply type its name followed by two presses of the Tab key – for instance, 'Base.<tab><tab>'.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"If there's only one command that matches your partial input, REPL will conveniently complete it for you. Get hands-on with this feature and see the leap in your coding efficiency!","category":"page"},{"location":"1_workflow/usage/#Summary","page":"Working with Julia in VSCode","title":"Summary","text":"","category":"section"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"In this session, we have explored how to effectively utilize Julia in Visual Studio Code (VSCode). Here's what we've accomplished:","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"We began by setting up our working environment in VSCode. We created a new folder for the workshop and a new file within that folder named introduction.jl. We then wrote and executed our first line of Julia code in this file, outputting \"Hello, Julia!\".\nWe dove deep into the Julia REPL (Read-Eval-Print Loop), an interactive command-line interface for the Julia programming language. We learned about the different modes in the REPL: Julia mode (the default), Help mode (for accessing documentation), and Package mode (for managing Julia packages). We practiced executing simple Julia expressions in the REPL, using Help mode to retrieve documentation, and using Package mode to add, update, and remove packages.\nWe covered how to restart the REPL, which is crucial when making changes to our code. We learned the key commands to perform a restart and understood that it effectively wipes the slate clean, removing any previously defined variables or loaded packages.\nFinally, we discovered the utility of the Tab key in the REPL for autocompletion and to see what's available in the current scope.","category":"page"},{"location":"1_workflow/usage/","page":"Working with Julia in VSCode","title":"Working with Julia in VSCode","text":"Through these steps, we have set up our workspace, started working with Julia code, navigated different modes in the REPL, managed packages, and learned key functions of the VSCode environment. The practices we've established will lay a strong foundation for our upcoming work with Julia in VSCode.","category":"page"},{"location":"reuse/abstract/","page":"-","title":"-","text":"Julia is a high-level dynamic programming language designed for numerical and scientific computing, data analysis, machine learning, and more. Julia's user-friendly interface, resembling popular languages like R, Python, and Matlab, makes it easily accessible for learners. Its focus on performance, however, enables computational speeds that often rival, or even surpass, those of low-level languages such as C or Fortran. Therefore, Julia is an ideal choice for large-scale data analysis and other computationally intensive tasks, as it can be orders of magnitude faster than R or Python. In this workshop, we will introduce you to the basics of Julia and the key features that set it apart from other languages.","category":"page"},{"location":"reuse/abstract/","page":"-","title":"-","text":"This workshop is designed for R/Python/Matlab users interested in learning a new programming language or wanting to improve their data analysis and scientific computing skills. No prior experience with Julia is required, but understanding a programming language is recommended.","category":"page"},{"location":"0_preparation/preparation/#Preparation","page":"Chapter 0: Preparation","title":"Preparation","text":"","category":"section"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"In this chapter, you will learn how to use julia (installation, setup, loading packages, creating scripts, etc.) If you are an in-person participant in this workshop, you should have received a mail prior to the workshop to complete the Preparation instructions. If you did, you can skip this part and continue with Working with Julia in VSCode. If you are doing the workshop online or were too lazy to follow the mailed instructions, you should proceed with Preparation.","category":"page"},{"location":"0_preparation/preparation/#Installing-Julia","page":"Chapter 0: Preparation","title":"Installing Julia","text":"","category":"section"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"Before we begin working with Julia, it's essential to have the language properly installed on your computer. Follow the steps below to install Julia:","category":"page"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"Go to the official Julia Website and navigate to the \"Downloads\" section.\nChoose the current stable release for your operating system (Windows, macOS, or Linux), download it, and install it.\n(Optional:) To verify the installation:\nopen the terminal (Windows: Windows key for Windows then type cmd, Mac: Cmd + Space for Spotlight then type terminal)\nIn the terminal: type julia.\nIf a new prompt appears, you have successfully installed Julia on your system. Try, e.g., 1 + 1","category":"page"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"Now that you have Julia installed, we can proceed to set up your development environment.","category":"page"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"The workshop, as it currenty is, was tested with the following Julia version:","category":"page"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"VERSION #hide","category":"page"},{"location":"0_preparation/preparation/#Installing-Visual-Studio-Code-(VSCode)","page":"Chapter 0: Preparation","title":"Installing Visual Studio Code (VSCode)","text":"","category":"section"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"Visual Studio Code (VSCode) is a popular and versatile integrated development environment (IDE) that offers excellent support for Julia, making it our recommended choice for this workshop.","category":"page"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"Download the installer.\nOnce the download is complete, locate the installer file and run it. Follow the prompts and instructions to install VSCode.\nAfter the installation is complete, open VSCode.","category":"page"},{"location":"0_preparation/preparation/#Installing-Julia-extension-for-VSCode","page":"Chapter 0: Preparation","title":"Installing Julia extension for VSCode","text":"","category":"section"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"Now that you have VSCode installed and open, you'll need to add the Julia extension. Follow these steps:","category":"page"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"Open the Extensions view: Click on the square icon on the left-hand sidebar (or press Ctrl+Shift+X / Cmd+Shift+X) to open the Extensions view.\nSearch for the Julia extension: In the Extensions view, use the search bar at the top to search for \"Julia\" and select the extension called \"Julia\" from the author julialang.\nClick on the \"Install\" button on the top of the page.","category":"page"},{"location":"0_preparation/preparation/","page":"Chapter 0: Preparation","title":"Chapter 0: Preparation","text":"You have now successfully set up VSCode with Julia support, and are ready for the workshop!","category":"page"},{"location":"2_syntax/foundations/#Syntax-cheat-sheet","page":"Theory","title":"Syntax cheat sheet","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Welcome to the next chapter! We hope that you made it through the setup part without too many headaches. Please don't hesitate to ask us any questions or provide feedback on what you liked and didn't like or thought was too easy or too hard. Your input is always welcome and appreciated!","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"In the following, you will find a quick cheat sheet covering the basic Julia syntax. You will see that Julia's syntax is similar to Matlab, Python, and R (in this order). We recommend that you quickly skim this cheat sheet and do the exercises at the and of this chapter. You might want to keep this page open in another tab to have it as a reference at your disposal. There is a collection of side-by-side comparisons of Julia and R, Python or Matlab in the Additional Resources section of the Additional Materials chapter. Because these are more comprehensive, you should not need them during the workshop.","category":"page"},{"location":"2_syntax/foundations/#Variable-assignment","page":"Theory","title":"Variable assignment","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"In Julia, variables are used to store data and represent values in your program. Variables have a name and are assigned a value using the assignment operator =. Julia supports both regular (ASCII) variable names (like alpha) and Unicode variable names (like α).","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"my_variable = \"awesome\"\nα = 1\nnothing #hide","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"To create a Unicode variable, type a backslash followed by the Unicode character name, and then press the Tab key to convert it into the corresponding Unicode symbol. For example, type \\alpha and then press <tab> to create the α variable. If you are interested you can find a table of all available unicode characters and how to type them out in the Julia documentation.","category":"page"},{"location":"2_syntax/foundations/#Functions","page":"Theory","title":"Functions","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Excellent! Now that you have an understanding of variables and the use of unicode symbols, let's dive into the topic of functions.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"The basic syntax for defining a function in Julia is as follows:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function function_name(argument1, argument2)\n    # function body\n    return output\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function add(x, y)\n    return x + y\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can also define functions as:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function_name(argument1, argument2) = #function body","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function square(x)\n    return x*x\nend\n# or\nsquare(x) = x * x\nnothing #hide","category":"page"},{"location":"2_syntax/foundations/#Vectors","page":"Theory","title":"Vectors","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"first_vector = [1, 2, 3]\nnothing #hide","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Julia uses 1-based indexing, which means the first element has an index of 1:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"first_element = first_vector[1]\nnothing #hide","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can also assign a new value to an element of a vector via indexing:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"first_vector[1] = 10\nnothing #hide","category":"page"},{"location":"2_syntax/foundations/#Operations-on-Vectors","page":"Theory","title":"Operations on Vectors","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"second_vector = [4, 5, 6]\nnothing #hide","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"subtracted_vectors = first_vector - second_vector","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Vectors can be concetenated with the vcat function or the ; operator:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"concatenated_vector = vcat(first_vector, second_vector)\nconcatenated_vector = [first_vector; second_vector]","category":"page"},{"location":"2_syntax/foundations/#Broadcasting","page":"Theory","title":"Broadcasting","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"All functions can be applied element-wise to a collection (vector/matrix) by using the broadcast . operator. For example, we can take the element-wise square root of a vector:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"sqrt.(first_vector)","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Or we mutliply two vectors element-wise:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"first_vector .* second_vector","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Note that infix operators (i.e., +, *, =, and many more) place the dote before the operator (i.e., .+, `.,.=`)","category":"page"},{"location":"2_syntax/foundations/#Sequences","page":"Theory","title":"Sequences","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Create a range of integers from 1 to 10:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"integer_sequence = 1:10","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Create a range with a specific step size:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"even_sequence = 2:2:10","category":"page"},{"location":"2_syntax/foundations/#Matrices","page":"Theory","title":"Matrices","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"Create a square matrix of integers:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"my_matrix = [1 2 3; 4 5 6]\n# or alternatively:\nmy_matrix = \n    [1 2 3\n    4 5 6]","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"As you can see, you can put rows in the matrix on different rows of your script, or separate them by semicolons ;.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can access elements of a matrix by specifying the row and column indices in square brackets, separated by a comma.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"upper_left_element = my_matrix[1, 1]\nlower_right_element = my_matrix[2, 3]\nnothing #hide","category":"page"},{"location":"2_syntax/foundations/#Control-Flow","page":"Theory","title":"Control Flow","text":"","category":"section"},{"location":"2_syntax/foundations/#For-Loops","page":"Theory","title":"For Loops","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"for variable in collection\n    # Code to be executed for each value in the collection\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"for i in 1:5\n    println(i^2)\nend","category":"page"},{"location":"2_syntax/foundations/#Conditional-evaluation","page":"Theory","title":"Conditional evaluation","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"if condition\n    # Code to be executed if the condition is true\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"You can also use elseif and else to test multiple conditions:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"if condition1\n    # Code to be executed if condition1 is true\nelseif condition2\n    # Code to be executed if condition1 is false and condition2 is true\nelse\n    # Code to be executed if both condition1 and condition2 are false\nend","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"For example, to check if a number is positive, negative, or zero:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"number = -3\n\nif number > 0\n    println(\"The number is positive\")\nelseif number < 0\n    println(\"The number is negative\")\nelse\n    println(\"The number is zero\")\nend","category":"page"},{"location":"2_syntax/foundations/#Packages","page":"Theory","title":"Packages","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"The section Package mode explained how to install packages. To use an installed package called Example in the current session:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"using Example","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"This makes all functions from the Example package available, for example the function hello:","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"hello(\"world\")","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"(As you can see, this is very similar to library(Example) in R or import Example in Python)","category":"page"},{"location":"2_syntax/foundations/#Exercises","page":"Theory","title":"Exercises","text":"","category":"section"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"compat: Exercise\nWrite a function that takes two arguments and divides them.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"tip: Solution\nfunction divide(a, b)\n    return a/b\nend\n# or\ndivide(a, b) = a/b","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"function divide(a, b)\n    return a/b\nend\n# or\ndivide(a, b) = a/b","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"\n","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"compat: Exercises\nCreate a vector of numbers and perform an element-wise square. Hint: In julia, a variable x can be squared with x^2.","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"tip: Solution\na = [1 2 3]\na .^ 2\n# or\na .* a","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"a = [1 2 3]\na .^ 2\na .* a","category":"page"},{"location":"2_syntax/foundations/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"using InteractiveUtils","category":"page"},{"location":"3_types/types/#Types","page":"Theory","title":"Types","text":"","category":"section"},{"location":"3_types/types/#Introduction","page":"Theory","title":"Introduction","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"In julia, every variable has a type.  We can use the function typeof (just like in R) to tell us the type of a variable. For example:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"a = 1.0\ntypeof(a)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"b = \"Hello!\"\ntypeof(b)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"c = rand(10)\ntypeof(c)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We see that, for example, the type of double-precision floating point numers is called Float64 in julia.","category":"page"},{"location":"3_types/types/#Abstract-Types","page":"Theory","title":"Abstract Types","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"However, in addition to the types a variable can have, there are so-called \"abstract types\". Abstract types \"bundle\" concrete types together, and form a \"type hierarchy\". Let's have a look:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"typeof(a)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"supertype(Float64)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"subtypes(AbstractFloat)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"The function supertype allows us to inspect the next higher abstract type in the type hierarchy. In this case, this type is called AbstractFloat Caling subtypes on AbstractFloat, we see that Float64 is \"bundled\" together with some other types, for example single precision floating point numbers (Float32). If we would explore this type hierarchy further, we could see something like:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"(Image: Type hiearchy) By Cormullion - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=83858572","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"In julia, we can easily define new abstract types:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"abstract type MySpecialNumber <: Number end","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"defines a new abstract type MySpecialNumber that is a subtype of Number.","category":"page"},{"location":"3_types/types/#Composite-types","page":"Theory","title":"Composite types","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"The most import kind of type we will encounter during this workshop is called a \"composite type\". Composite types are also called \"structs\" and they allow us to create very useful objects.  For example, suppose we are writing a video game for the well-known Pokemon series [1],  we could define some abstract types","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"abstract type Pokemon end\nabstract type Normal <: Pokemon end\nabstract type Flying <: Pokemon end\nabstract type Electric <: Pokemon end","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"and then a composite type","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"struct Pikachu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\nend","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We now have an abstract type Pokemon with subtypes Normal, Flying and Electric, and a composite type Pikachu which is a subtype of Electric. The composite type Pikachu has the \"fields\" nickname, attack, defense, speed and hp, where we can store the respective values.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We are now able to create our very own Pikachu to fight in our team:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"my_pikachu = Pikachu(\"Pika\", 135, 80, 110, 132)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"which creates a variable my_pikachu of type Pikachu.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"We can retrieve the values stored in the fields as","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"my_pikachu.defense","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"One thing to notice is that types cannot be re-defined in a running julia session. For example, trying to re-define the Pikachu type will result in an error:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"struct Pikachu <: Electric\n    nickname\n    attack\nend","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"ERROR: invalid redefinition of constant Pikachu","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"In Julia, once a type is defined, it is locked in place due to the language's \"just-in-time\" compilation process. This feature enhances performance during normal use, but it can be a little cumbersome during a workshop where you are programming interactively. For example, you might want to try things out, or you made an error while defining a type. Unfortunately, correcting your error makes it necessary to restart Julia. Luckily, you did learn how to do that at the beginning of the workshop – remember that you can use the VSCode command palette.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"compat: Exercise\nCreate a new composite type for a pokemon of your choice of type Flying, create an instance of that pokemon, and retrieve it's nickname.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"tip: Solution\nstruct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)\nmy_crobat.nickname","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"struct Crobat <: Flying\n    nickname\n    attack\n    defense\n    speed\n    hp\nend\n\nmy_crobat = Crobat(\"Xwing\", 105, 100, 210, 112)\nmy_crobat.nickname","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"</details>","category":"page"},{"location":"3_types/types/#Constructors","page":"Theory","title":"Constructors","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Let's talk about how we create new objects. In the example above, we called the type (Pikachu, Crobat) with the values we want to store in the respective fields (Pikachu(\"Pika\", 135, 80, 110, 132)) to create a new instance of that pokemon. However, we may like to have more convenience or safety. For this purpose, we have Constructors: functions that create new objects.","category":"page"},{"location":"3_types/types/#Outer-Constructors","page":"Theory","title":"Outer Constructors","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Outer constructors are mainly for conveniece reasons, and we define them just like functions. For example, we may want to have the option of not giving a new Pokemon a nickname:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"import Random: randstring\nPikachu(attack, defense, speed, hp) = Pikachu(randstring(10), attack, defense, speed, hp)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"So if I want to be lazy and not come up with a nickname, i just sample a random one:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"my_lazy_pikachu = Pikachu(132, 34, 23, 343)","category":"page"},{"location":"3_types/types/#Inner-Constructors","page":"Theory","title":"Inner Constructors","text":"","category":"section"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Inner constructors can be used for enforcing that newly created objects obey certain rules. For example, the way we defined our Pikachu type, there was nothing to tell julia which kind of objects we actually can store in the fields. This allows us to do something like this:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"weird_pikachu = Pikachu(132, 34, 23, -12)","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Of course, this is not a valid Pokemon, as the maximum health points can't be negative. To fix this, we use an inner constructor. This is just another function, but defined inside the type definition. Suppose we define another type of Pokemon like this:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"struct Pichu <: Electric\n    nickname\n    attack\n    defense\n    speed\n    hp\n    function Pichu(nickname, attack, defense, speed, hp)\n        if (attack < 0) | (defense < 0) | (speed < 0) | (hp < 0)\n            error(\"Your Pokemon's stats are outside the valide range\")\n        else\n            return new(nickname, attack, defense, speed, hp)\n        end\n    end\nend","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"So we add a function to the type definition that has the same name as the type. This function checks whether the inputs are valid and throws an error if not. If they are valid, it uses the special new function (which is only available inside type definitions) to create a new (hopefully valid) object.","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"Let's check if it works:","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"try  #hide\nweird_pichu = Pichu(\"Pika_2.0\", 132, 34, 23, -12)\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"3_types/types/","page":"Theory","title":"Theory","text":"[1]: Inspired by https://gdalle.github.io/JuliaComputationSolutions/hw1a_solutions.html","category":"page"},{"location":"5_additional/links/#Useful-Links","page":"Useful Links","title":"Useful Links","text":"","category":"section"},{"location":"5_additional/links/#Official-Documentation","page":"Useful Links","title":"Official Documentation","text":"","category":"section"},{"location":"5_additional/links/","page":"Useful Links","title":"Useful Links","text":"Arguably the most important and useful link is the one to the official Julia Documentation. It might be quite technical from time to time, but is a great and extensive documentation of many aspects of the Julia language. Once you are more familiar with julia, the sections Performance Tips and the Style Guide might be especially helpful.","category":"page"},{"location":"5_additional/links/#Use-Juliaup-for-Julia-Version-Management","page":"Useful Links","title":"Use Juliaup for Julia Version Management","text":"","category":"section"},{"location":"5_additional/links/","page":"Useful Links","title":"Useful Links","text":"If you're comfortable using the shell and already have some experience with the terminal, you may want to install Juliaup. It helps you to manage multiple versions of the Julia programming language and you'll be notified when a new version becomes available. To install Juliaup, check out the Juliaup GitHub page. After the installation just execute juliaup add release in your terminal and you're ready to go.","category":"page"},{"location":"5_additional/links/#OhMyREPL","page":"Useful Links","title":"OhMyREPL","text":"","category":"section"},{"location":"5_additional/links/","page":"Useful Links","title":"Useful Links","text":"If you like working in the Julia REPL, but you miss things like syntax highlighting and bracket completion, you may want to check out OhMyREPL.","category":"page"},{"location":"5_additional/links/#Style-Guide","page":"Useful Links","title":"Style Guide","text":"","category":"section"},{"location":"5_additional/links/","page":"Useful Links","title":"Useful Links","text":"If you are interested in how to write beautiful Julia code, this Style Guide might be helpful.","category":"page"},{"location":"5_additional/links/#Profiling","page":"Useful Links","title":"Profiling","text":"","category":"section"},{"location":"5_additional/links/","page":"Useful Links","title":"Useful Links","text":"If your code is slow and you don't know why, profiling can help you find the problematic parts. We like the ProfileView.jl package.","category":"page"},{"location":"5_additional/links/#Books","page":"Useful Links","title":"Books","text":"","category":"section"},{"location":"5_additional/links/","page":"Useful Links","title":"Useful Links","text":"Julia Data Science - Free Online Book\nHands on Design Patterns and Best Practices with Julia - Great but not free","category":"page"},{"location":"5_additional/links/#Cheat-sheets","page":"Useful Links","title":"Cheat sheets","text":"","category":"section"},{"location":"5_additional/links/","page":"Useful Links","title":"Useful Links","text":"Julia Overview\nMATLAB–Python–Julia comparison\nJulia-R comparison\nJulia-Python-R comparison\nNoteworthy differences to other Languages\nData Wrangling with DataFrames.jl","category":"page"},{"location":"5_additional/dual/#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Obtaining function derivatives is central in many areas of scientific computing. For example, in numerical optimization, we often need derivatives to find the minimum of a function (maximum likelihood estimation, neural networks, ...). However, deriving derivatives by hand can be quite tedious, especially if you work with frequently changing functions. As numerical differentiation is computationally quite expensive, automatic differentiation libraries have been developed. For example, most Deep Learning libraries employ a form of automatic differentiation called \"backpropagation\". In this example, we will implement one form of automatic differentiation, called \"Forward mode AD\".[1]","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To do so, we heavily rely on the chain rule:  suppose we have functions f mathbbR to mathbbR  g mathbbR to mathbbR. If we compose these functions, we can derive their derivative as ","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"(f(g(x))) = f(g(x)) cdot g(x)","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"With a little bit abuse of notation, instead of defining two functions f and g we will write in the following x mathbbR to mathbbR as a function itself, so the chain rule becomes:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"(f(x)) = f(x) cdot x","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Using the chain rule together with all the other basic differentiation rules you hopefully remember from high school gives:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"beginaligned\n(x + y) = x + y \n(x - y) = x - y \n(x cdot y) = xcdot y + x cdot y \nleft(frac1xright) = frac-xx^2 \nleft(fracxyright) = fracx cdot y - x cdot yy^2 \n(log(x)) = frac1x cdot x \n(sin(x)) = cos(x) cdot x \n(cos(x)) = -sin(x) cdot x \nleft(x^kright) = k cdot x^k-1 cdot x\nendaligned","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"As most functions are compositions of basic functions (of course our list above is not exhaustive, but already sufficient for a lot of things), we can use the chain rule and the differentiation rules for those basic building blocks to \"propagate\" the derivative through more complex functions (just like we propagated the measurement error in the example in Chapter 3).","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nDefine a struct Dual that stores a function value as well as it's derivative as a subtype of Number.","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nstruct Dual <: Number\n    x\n    ∂x\nend","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"struct Dual <: Number\n    x\n    ∂x\nend","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nDefine methods for some of the basic functions described above: +, -, *, /, inv, log, sin, cos, ^. Remember that you have to import them from Base. Don't do all of them (it's tedious), just a few to get the idea.","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>Hint</summary>\n<br>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Hint\nWe could define the multiplication of two dual numbers as:import Base: *\n*(a::Dual, b::Dual) = Dual(a.x*b.x, a.∂x*b.x + a.x*b.∂x)","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: *\n*(a::Dual, b::Dual) = Dual(a.x*b.x, a.∂x*b.x + a.x*b.∂x)","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nimport Base: +, -, *, /, inv, log, sin, cos, ^\n\n+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)\n-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)\n*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)\n^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)\n/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)\ninv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))\nlog(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))\nsin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)\ncos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: +, -, *, /, inv, log, sin, cos, ^\n\n+(a::Dual, b::Dual) = Dual(a.x + b.x, a.∂x + b.∂x)\n-(a::Dual, b::Dual) = Dual(a.x - b.x, a.∂x - b.∂x)\n*(a::Dual, b::Dual) = Dual(a.x * b.x, a.∂x*b.x + a.x*b.∂x)\n^(a::Dual, k::Int) = Dual(a.x^k, k*a.x^(k-1)*a.∂x)\n/(a::Dual, b::Dual) = Dual(a.x/b.x, (a.∂x*b.x - a.x*b.∂x)/b.x^2)\ninv(a::Dual) = Dual(inv(a.x), -a.∂x/(a.x^2))\nlog(a::Dual) = Dual(log(a.x), -a.∂x/(a.x^2))\nsin(a::Dual) = Dual(sin(a.x), cos(a.x)*a.∂x)\ncos(a::Dual) = Dual(cos(a.x), -sin(a.x)*a.∂x)","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\nOf course we also want to be able to have constants in our functions. To make our life a little bit easier, we can treat constant values (aka real numbers) as dual numbers with a derivative of 0. For this purpose, we define how to convert a real number into a dual number, and a \"promotion rule\":","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"import Base: convert, promote_rule\n\nconvert(::Type{Dual}, x::Real) = Dual(x, zero(x))\npromote_rule(::Type{Dual}, ::Type{<:Real}) = Dual\nnothing #hide","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We did not cover conversion and promotion in this workshop, so you won't understand this in detail, but the short explanation is this: We write a method for the convert function to tell julia how to \"convert\" an object of type Real to an object of type Dual, so we can now do something like this:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nconvert(Dual, a)","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"that is, a Real number is converted to a dual with a derivative of zero. The promotion rule defines a greater type of two types so that all objects of these types can be converted to it. We now can do something like:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nb = Dual(3.2, 3.47)\npromote(a, b)","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"So given a pair of a Dual and a Real number, promote both numbers to Duals. The beauty of this is that we now can add, multiply, divide, etc. reals and duals without defining any further methods:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a = 3.23\nb = Dual(3.2, 3.47)\na*b","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a+b","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"a/b","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This is because julia will now \"check\" the defined promotion rules for us, and promote the real number to a dual number, and then use the methods we defined before. If you are interested in details, check the documentation on this topic, but for now it suffices to see that we avoided defining a bunch of methods with this neat trick.","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Now we have implemented a library for automatic differentiation! Let's come up with some random function to take the derivative of:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"f(x) = (x^2*sin(x))/cos(x)^2","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To compute the derivative at point x, simply call the function with Dual(x, 1.0) (as 1.0 is the derivative of the identity function x):","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"f(Dual(5.0, 1.0))","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"This gives the function value and the derivative of f at point 5. Another function and it's derivative:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"g(x) = log(x)/sin(x^5)\ng(Dual(π, 1.0))","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We can check that we did not messed up by either deriving the derivative by hand or using a numerical approximation:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using FiniteDiff\nFiniteDiff.finite_difference_derivative(g, Float64(π))","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"We can also take the partial derivative of functions h mathbbR^n to mathbbR:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"h(x) = sin(x[1]*x[2]^2-x[3])/log(x[1])\nh([4.3, Dual(6.45, 1.0), 3.42])","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"gives the partial derivative w.r.t. x_2 at the point (43 645 342):","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"FiniteDiff.finite_difference_gradient(h, [4.3, 6.45, 3.42])","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"To sum up, let's get back to our example from the beginning: linear regression. Recall our setup:","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"using Random\nRandom.seed!(1243)\n\nx = 10 .+ 3*randn(20)\nβ = 300\nα = 1000\ny = α .+ β*x + 500*randn(20)\n\nfunction predict(x, α, β)\n    y = α .+ β*x\n    return y\nend\n\nfunction squared_error(y, ŷ)\n    return sum((y - ŷ).^2)\nend\nnothing #hide","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Exercise\nCompute the derivative of the squared error w.r.t. β at the point β = 200, α = 1000.","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>Hint</summary>\n<br>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"compat: Hint\nRecall you can compute the squared error assquared_error(y, predict(x, α, β))","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"\n","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"tip: Solution\nsquared_error(y, predict(x, 1000, Dual(200.0, 1.0)))","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"squared_error(y, predict(x, 1000, Dual(200.0, 1.0))) #hide","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"</details>","category":"page"},{"location":"5_additional/dual/","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"[1]: This example is inspired by https://www.wias-berlin.de/people/fuhrmann/AdSciComp-WS2223/week3/","category":"page"},{"location":"reuse/chapter-overview/","page":"-","title":"-","text":"Chapter 0 should aready be completed before the workshop begins, unless you are doing it on your own. There we guide you through the installation of the Julia and Visual Studio Code.","category":"page"},{"location":"reuse/chapter-overview/","page":"-","title":"-","text":"Chapter 1 is the first chapter that we tackle together (unless you are on your own). Before diving into the intricacies of Julia, we will first discuss the workflow and tools you'll need to get started with the language. This will help you familiarize yourself with the environment, become proficient in using Julia, and empower you to troubleshoot any issues you may encounter.","category":"page"},{"location":"reuse/chapter-overview/","page":"-","title":"-","text":"Chapter 2 is meant to make the Julia syntax more familiar to you. This is meant to help you translate concepts that you already know from other programming languages like, e.g., assignment, control flow, functions, etc.","category":"page"},{"location":"reuse/chapter-overview/","page":"-","title":"-","text":"Chapter 3 is about things that exist in Julia. Everything that exists in Julia has a type. Without understanding types, you can not understand Julia. What better why to understand than to create your own type?","category":"page"},{"location":"reuse/chapter-overview/","page":"-","title":"-","text":"Chapter 4 is about things that happen in Julia. Everything that happens in Julia is because of functions. What functions do is deeply integrated with Julia's type system trough a prosses called mutliple dispatch. This chapter shows you how to leverage this system to do amazing things, hardly possible somewhere else.","category":"page"},{"location":"preparation/","page":"-","title":"-","text":"<!-- Note: don't tell people to `click` the link, just tell them that it is a link. -->\n<meta http-equiv=\"refresh\" content=\"1; url=https://formal-methods-mpi.github.io/Workshop.jl/stable/0_preparation/preparation/\">\n \n<script>\n  window.location.href = \"https://formal-methods-mpi.github.io/Workshop.jl/stable/0_preparation/preparation/\"\n</script>\n \n<title>Page Redirection</title>\n \nIf you are not redirected automatically, follow the <a href='https://formal-methods-mpi.github.io/Workshop.jl/stable/0_preparation/preparation/'>link to the preparation</a>","category":"page"},{"location":"3_types/exercise/#Exercise:-Measurements","page":"Exercise","title":"Exercise: Measurements","text":"","category":"section"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"In this exercise, you will define a type which is (hopefully) more closely related to your research than Pokemon. We will continue our example from the first chapter, linear regression. Suppose you collected your data on education, but with some measurement error (people lie about their education, or they are not shure what exactly counts into the number of years, ...). Of course this is not limited to the example of education, but observing data with measurement error is a central concept in most empirical sciences.","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine the composite type Measurement, that is able to store a measurement and the magnitude of error of that measurement. It should be a subtype of AbstractFloat and have an inner constructor that converts the magnitude of measurement to a positive number. Hint: you can use the function abs(...) to take the absolute value of a number.","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\nstruct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"struct Measurement <: AbstractFloat\n    value\n    error\n    Measurement(val, err) = new(val, abs(err))\nend","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"\n","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"compat: Exercise\nDefine the function ±(value, error) to create a new instance of the Measurement type, and create some measurements.","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"<details>\n<summary>show solution</summary>\n<br>","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"tip: Solution\n±(val, err) = Measurement(val, err)\n\nm1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"±(value, error) = Measurement(value, error)\n\nm1 = 2.98 ± 0.43\nm2 = 0.34 ± 1.34","category":"page"},{"location":"3_types/exercise/","page":"Exercise","title":"Exercise","text":"</details>","category":"page"},{"location":"5_additional/intro/#Additional-Materials","page":"Introduction","title":"Additional Materials","text":"","category":"section"},{"location":"5_additional/intro/","page":"Introduction","title":"Introduction","text":"This chapter contains some additional materials and exercises. You should do it only after you finished the rest of the workshop. You can do them in any order, just pick something you are interested in.","category":"page"},{"location":"5_additional/intro/","page":"Introduction","title":"Introduction","text":"Automatic Differentiation contains an advanced exercise of building an automatic differentiation system from scratch\nUseful Links is a collection of further materials that may be useful.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Workshop","category":"page"},{"location":"#What-this-workshop-is-about","page":"Home","title":"What this workshop is about","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hello and welcome to our Julia workshop!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Together, we'll be exploring the amazing world of Julia, a powerful programming language that's taking the world of scientific computing, data science, and research by storm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia is not only known for its ease of use, but also its incredible speed and flexibility. These qualities make it an excellent choice for developers, data scientists, and researchers alike. Let's dive into some of the key reasons why Julia is so awesome:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Superior performance: Julia is fast – very fast. It eliminates the need to use C/C++, Fortran, or other \"slow-productivity\" or \"slow-prototyping\" languages, effectively solving the \"two-language problem.\" This means you can focus on one language for both development and performance optimization.\nUser-friendly syntax: Julia boasts a simple and intuitive syntax that makes it easy for beginners to pick up and for experts to master.\nAdvanced support for Unicode and LaTeX characters: Julia makes it simple to incorporate Unicode and LaTeX characters into your code. Say goodbye to \"alpha\" and \"beta\" and embrace the elegance of α and β.\nRapid prototyping: With Julia, it's easy to add and prototype new algorithms right from the start, allowing you to quickly create efficient, high-performance solutions.","category":"page"},{"location":"#How-to-get-started","page":"Home","title":"How to get started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As this is an asynchronous workshop, you might be reading this before, during, or after the workshop. Regardless of when you're engaging with the material, we hope you'll find this workshop useful and informative.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To ensure a smooth learning experience, we have divided the workshop into three main stages: pre-workshop preparation, hands-on activities during the workshop, and post-workshop exploration.","category":"page"},{"location":"#Pre-workshop-preparation","page":"Home","title":"Pre-workshop preparation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is important that you install Julia and Visual Studio Code following the steps outlined in Chapter 0.","category":"page"},{"location":"#During-the-workshop","page":"Home","title":"During the workshop","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We will focus on what sets Julia apart from other programming languages working hands-on with Julia in Visual Studio Code (VSCode). Through hands-on activities, you'll gain practical experience to reinforce your understanding of the concepts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core of this workshop consists of 5 chapters (Chapter 0 - Chapter 4) that you can see in the sidebar on the left. They are meant to be completed in your own pace but in this order (0-4).","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Markdown; Markdown.parse_file(\"../src/reuse/chapter-overview.md\")","category":"page"},{"location":"#Post-workshop-exploration","page":"Home","title":"Post workshop exploration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After the workshop, we encourage you to continue experimenting with Julia, apply the skills you've learned to real-world projects, and leverage the resources and community support available to further your knowledge. To start you on this journey we have prepared the Additional Materials section. By thoughtfully engaging with the workshop content and activities, you'll be well-prepared to harness the full potential of Julia and excel in your projects.","category":"page"}]
}
